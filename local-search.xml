<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hazard Pointers</title>
    <link href="/2023/01/08/hazard-pointers/"/>
    <url>/2023/01/08/hazard-pointers/</url>
    
    <content type="html"><![CDATA[<h1 align="center">Hazard Pointers</h1><h2 align="center">Safe Memory Reclamation forLock-Free Objects</h2><p align="center">Maged M. Michael</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Lock-free objects offer significant performance and reliability advantages over conventional lock-based objects. However, the lack of an efficient portable lock-free method for the reclamation of the memory occupied by dynamic nodes removed from such objects is a major obstacle to their wide use in practice. This paper presents hazard pointers, a memory management methodology that allows memory reclamation for arbitrary reuse. It is very efficient, as demonstrated by our experimental results. It is suitable for user-level applications—as well as system programs—without dependence on special kernel or scheduler support. It is wait-free. It requires only single-word reads and writes for memory access in its core operations. It allows reclaimed memory to be returned to the operating system. In addition, it offers a lock-free solution for the ABA problem using only practical single-word instructions. Our experimental results on a multiprocessor system show that the new methodology offers equal and, more often, significantly better performance than other memory management methods, in addition to its qualitative advantages regarding memory reclamation and independence of special hardware support. We also show that lock-free implementations of important object types, using hazard pointers, offer comparable performance to that of efficient lock-based implementations under no contention and no multiprogramming, and outperform them by significant margins under moderate multiprogramming and&#x2F;or contention, in addition to guaranteeing continuous progress and availability, even in the presence of thread failures and arbitrary delays.</p><p>无锁（Lock-free）对象比传统的基于锁的对象提供了显著的性能和可靠性等优点。然而，由于缺乏一个有效可移植的无锁方法来回收这些对象中删除掉的动态节点所占用的内存，成为了在实践中广泛应用该方法的一个主要障碍。本文介绍了风险指针（Hazard Pointers），这是一种内存管理方法，允许内存被回收后任意重用。我们的实验结果证明，这是非常有效的。它适用于用户级应用程序，也适用于系统程序，不依赖于特殊的内核调度的支持。它是无等待的（wait-free）。其核心操作仅需要单字的内存读取和写入访问。它允许被回收的内存被返还给操作系统。此外，仅仅使用实际的单字指令，它还提供了 ABA 问题的一个无锁解决方案。除了其在内存回收和独立于特殊硬件支持这些质量优势之外，我们在多处理器系统中的实验结果还显示，相比其他内存管理方法，该新方法提供了同等的，在更多的时候，甚至明显更好的性能。我们还表明，使用风险指针（Hazard Pointers）的重要对象类型的无锁实现与高效的基于锁的实现相比，提供了在无争用无多道程序的情况下同等的性能，在中等多道程序和中等争用情况下显著优于它们，此外，甚至在存在的线程失败和任意延迟的情况下，也能保证持续进展和其可用性。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>A shared object is lock-free (also called nonblocking) if it guarantees that whenever a thread executes some finite number of steps toward an operation on the object, some thread (possibly a different one) must have made progress toward completing an operation on the object, during the execution of these steps. Thus, unlike conventional lock-based objects, lock-free objects are immune to deadlock when faced with thread failures, and offer robust performance, even when faced with arbitrary thread delays.</p><p>共享对象是无锁的（lock-free）（也称为非阻塞的，nonblocking），如果它能保证当一个线程在对象上执行一些有限次数的操作步骤，在执行这些步骤期间，某个线程（可能是不同的线程），必须能朝着完成在该对象上的操作的方向上取得进展。因此，它不同于传统的基于锁的对象，在面临线程失败的时候，无锁对象是死锁免疫的；即使面对任意的线程延迟，也提供了稳健的性能。</p><p>Many algorithms for lock-free dynamic objects have been developed, e.g., <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>, <sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.">[9]</span></a></sup>, <sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="S. Prakash, Y.-H. Lee, and T. Johnson, “A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap,” IEEE Trans. Computers, vol. 43, no. 5, pp. 548-559, May 1994.">[23]</span></a></sup>, <sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.">[21]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, “A Pragmatic Implementation of Non-Blocking Linked Lists,” Proc. 15th Int’l Symp. Distributed Computing, pp.*nbsp;300-314, Oct. 2001.">[5]</span></a></sup>, <sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.">[16]</span></a></sup>, <sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.">[7]</span></a></sup>, <sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><span class="hint--top hint--rounded" aria-label="O. Shalev and N. Shavit, “Split-Ordered Lists: Lock-Free Extensible Hash Tables,” Proc. 22nd Ann. ACM Symp. Principles of Distributed Computing, pp. 102-111, July 2003.">[25]</span></a></sup>, <sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “CAS-Based Lock-Free Algorithm for Shared Deques,” Proc. Ninth Euro-Par Conf. Parallel Processing, pp. 651- 660, Aug. 2003.">[18]</span></a></sup>. However, a major concern regarding these objects is the reclamation of the memory occupied by removed nodes. In the case of a lock-based object, when a thread removes a node from the object, it is easy to guarantee that no other thread will subsequently access the memory of that node, before it is reused or reallocated. Consequently, it is usually safe for the removing thread to reclaim the memory occupied by the removed node (e.g., using free) for arbitrary future reuse by the same or other threads (e.g., using malloc)</p><p>已经开发出了许多无锁动态对象的算法，例如 <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>,<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.">[9]</span></a></sup>, <sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="S. Prakash, Y.-H. Lee, and T. Johnson, “A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap,” IEEE Trans. Computers, vol. 43, no. 5, pp. 548-559, May 1994.">[23]</span></a></sup>, <sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.">[21]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, “A Pragmatic Implementation of Non-Blocking Linked Lists,” Proc. 15th Int’l Symp. Distributed Computing, pp.*nbsp;300-314, Oct. 2001.">[5]</span></a></sup>, <sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.">[16]</span></a></sup>, <sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.">[7]</span></a></sup>, <sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><span class="hint--top hint--rounded" aria-label="O. Shalev and N. Shavit, “Split-Ordered Lists: Lock-Free Extensible Hash Tables,” Proc. 22nd Ann. ACM Symp. Principles of Distributed Computing, pp. 102-111, July 2003.">[25]</span></a></sup>, <sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “CAS-Based Lock-Free Algorithm for Shared Deques,” Proc. Ninth Euro-Par Conf. Parallel Processing, pp. 651- 660, Aug. 2003.">[18]</span></a></sup> 。但是，关于这些对象的一个主要关注的问题是，如何回收已经删除掉的节点所占用的内存。在基于锁的对象的情形下，当线程从对象中删除一个节点时，在它被重用或者重新分配之前，很容易保证没有其他线程会在此后访问该节点的内存。因此，删除线程通常可以安全地回收被删除节点占用的内存（例如，使用 free），以便将来由相同或其他线程（例如，利用malloc）任意重用。</p><p>This is not the case for a typical lock-free dynamic object, when running in programming environments without support for automatic garbage collection. In order to guarantee lock-free progress, each thread must have unrestricted opportunity to operate on the object, at any time. When a thread removes a node, it is possible that some other contending thread—in the course of its lock-free operation—has earlier read a reference to that node, and is about to access its contents. If the removing thread were to reclaim the removed node for arbitrary reuse, the contending thread might corrupt the object or some other object that happens to occupy the space of the freed node, return the wrong result, or suffer an access error by dereferencing an invalid pointer value. Furthermore, if reclaimed memory is returned to the operating system (e.g., using munmap), access to such memory locations can result in fatal access violation errors. Simply put, the memory reclamation problem is how to allow the memory of removed nodes to be freed (i.e., reused arbitrarily or returned to the OS), while guaranteeing that no thread accesses free memory, and how to do so in a lock-free manner.</p><p>对于典型的无锁动态对象，当在没有自动垃圾回收机制的环境中运行时，就不再是如此了。为了保证无锁的进展，每个线程必须要有无限制的机会在任意时间去操作该对象。当线程删除一个节点时，可能某个其他线程——在其无锁操作期间——已经在预先读取了该对象的一个引用，且正要访问其内容。如果删除线程真的回收了被删除节点的内存用以任意重用，那么争用线程就可能破坏该对象或者恰好占用已释放节点空间的其他对象，从而会返回错误结果，或者因为解引用无效指针而导致访问错误。进一步，如果被回收的内存被返还给了操作系统（例如使用 munmap），访问这样的内存位置就会导致致命的访问违例错误。简单点说，内存回收问题是如何允许被删除节点的内存被释放（即，被任意重用或者返还给 OS），同时还保证没有线程访问被释放的内存，以及如何以一种无锁的方式做到这一点。</p><p>Prior methods for allowing node reuse in dynamic lockfree objects fall into three main categories. 1) The IBM tag (update counter) method <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>, which hinders memory reclamation for arbitrary reuse and requires double-width instructions that are not available on 64-bit processors. 2) Lock-free reference counting methods <sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><span class="hint--top hint--rounded" aria-label="J.D. Valois, “Lock-Free Linked Lists Using Compare-and-Swap,” Proc. 14th Ann. ACM Symp. Principles of Distributed Computing, pp. 214-222, Aug. 1995.">[29]</span></a></sup>, <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="D.L. Detlefs, P.A. Martin, M. Moir, and G.L. Steele Jr., “Lock-Free Reference Counting,” Proc. 20th Ann. ACM Symp. Principles of Distributed Computing, pp. 190-199, Aug. 2001.">[3]</span></a></sup>, which are inefficient and use unavailable strong multiaddress atomic primitives in order to allow memory reclamation. 3) Methods that depend on aggregate reference counters or per-thread timestamps <sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="P.E. McKenney and J.D. Slingwine, “Read-Copy Update: Using Execution History to Solve Concurrency Problems,” Proc. 10th IASTED Int’l Conf. Parallel and Distributed Computing and Systems, Oct. 1998.">[13]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, “A Pragmatic Implementation of Non-Blocking Linked Lists,” Proc. 15th Int’l Symp. Distributed Computing, pp.*nbsp;300-314, Oct. 2001.">[5]</span></a></sup>. Without special scheduler support, these methods are blocking. That is, the failure or delay of even one thread can prevent an aggregate reference counter from reaching zero or a timestamp from advancing and, hence, preventing the reuse of unbounded memory.</p><p>之前的用以允许动态无锁对象的节点重用的方法主要可以分为3类。1）IBM 标记（更新计数器）法<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>，它阻碍了内存回收以供任意重用，并且需要在 64 位处理器上不可用的双字宽度指令。2）无锁引用计数法 <sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><span class="hint--top hint--rounded" aria-label="J.D. Valois, “Lock-Free Linked Lists Using Compare-and-Swap,” Proc. 14th Ann. ACM Symp. Principles of Distributed Computing, pp. 214-222, Aug. 1995.">[29]</span></a></sup>, <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="D.L. Detlefs, P.A. Martin, M. Moir, and G.L. Steele Jr., “Lock-Free Reference Counting,” Proc. 20th Ann. ACM Symp. Principles of Distributed Computing, pp. 190-199, Aug. 2001.">[3]</span></a></sup>，这种方法效率不佳，且为了允许内存回收还使用了不可用的强多地址原子原语。3）基于总体引用计数或者每个线程（per-thread）的时间戳的方法 <sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="P.E. McKenney and J.D. Slingwine, “Read-Copy Update: Using Execution History to Solve Concurrency Problems,” Proc. 10th IASTED Int’l Conf. Parallel and Distributed Computing and Systems, Oct. 1998.">[13]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, “A Pragmatic Implementation of Non-Blocking Linked Lists,” Proc. 15th Int’l Symp. Distributed Computing, pp.*nbsp;300-314, Oct. 2001.">[5]</span></a></sup>。如果没有特殊的调度器支持，这些方法都是阻塞的。也就是说，即使一个线程的失败或者延迟都会阻止总体引用计数到达零值，或者阻止时间戳被更新，从而阻止不定界的内存重用。</p><p>This paper presents hazard pointers, a methodology for memory reclamation for lock-free dynamic objects. It is efficient; it takes constant expected amortized time per retired node (i.e., a removed node that is no longer needed by the removing thread). It offers an upper bound on the total number of retired nodes that are not yet eligible for reuse, regardless of thread failures or delays. That is, the failure or delay of any number of threads can prevent only a bounded number of retired nodes from being reused. The methodology does not require the use of double-width or strong multiaddress atomic primitives. It uses only singleword reads and writes for memory access in its core operations. It is wait-free <sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “Wait-Free Synchronization,” ACM Trans. Programming Languages and Systems, vol. 13, no. 1, pp. 124-149, Jan. 1991.">[8]</span></a></sup>, i.e., progress is guaranteed for active threads individually, not just collectively; thus, it is also applicable to wait-free algorithms without weakening their progress guarantee. It allows reclaimed memory to be returned to the operating system. It does not require any special support from the kernel or the scheduler.</p><p>本论文介绍风险指针（hazard pointers），一种用以无锁动态对象的内存回收方法。它是高效的；它对每个退休节点（例如一个被删除的不再被删除线程需要的节点）的分摊时间是预期的常量。无论线程是失败还是延迟，它都能对不可重用的退休节点的总数保持一个上界。也就是说，任意数量的线程失败或者延迟都只能阻碍有限数量的退休节点不能被重用。该方法不要求使用双字或者更强大的多地址原子原语。在其核心操作中，它只使用单字内存读写访问。它是无等待的<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “Wait-Free Synchronization,” ACM Trans. Programming Languages and Systems, vol. 13, no. 1, pp. 124-149, Jan. 1991.">[8]</span></a></sup>，即，能保证每个活跃线程的进展，而不仅仅是总体的进展。因此，它也适用于无等待算法，而不会减弱他们对进展的保证性。它允许被回收的内存被返还给操作系统。它不要求内核或者调度器提供任何特殊支持。</p><p>The core idea is to associate a number (typically one or two) of single-writer multireader shared pointers, called hazard pointers, with each thread that intends to access lockfree dynamic objects. A hazard pointer either has a null value or points to a node that may be accessed later by that thread without further validation that the reference to the node is still valid. Each hazard pointer can be written only by its owner thread, but can be read by other threads.</p><p>核心思想是，将一些（通常是一个或两个）被称为风险指针（hazard pointers）的单写者多读者（single-writer multi-reader）的共享指针，与每一个想要访问无锁对象的线程关联起来。一个风险指针要么是 NULL，要么指向一个节点，该节点之后可能会被该线程访问，而不需要验证对该节点的这个引用是否有效。每个风险指针只能被其拥有者线程写入，但是可以被别的线程读取。</p><p>The methodology requires lock-free algorithms to guarantee that no thread can access a dynamic node at a time when it is possibly removed from the object, unless at least one of the thread’s associated hazard pointers has been pointing to that node continuously, from a time when the node was guaranteed to be reachable from the object’s roots. The methodology prevents the freeing of any retired node continuously pointed to by one or more hazard pointers of one or more threads from a point prior to its removal.</p><p>该方法要求无锁算法保证，当动态节点可能已经被从对象中删除掉的时候，没有任何线程可以访问该动态节点，除非该线程的至少一个关联的风险指针从该节点还可以保证能够从对象的根到达开始已经连续指向该节点。该方法防止释放任何已经在其被删除之前已经被一个或多个线程的一个或者多个风险指针指向的节点。</p><p>Whenever a thread retires a node, it keeps the node in a private list. After accumulating some number R of retired nodes, the thread scans the hazard pointers of other threads for matches for the addresses of the accumulated nodes. If a retired node is not matched by any of the hazard pointers, then it is safe for this node to be reclaimed. Otherwise, the thread keeps the node until its next scan of the hazard pointers.</p><p>每当一个线程退休一个节点，它就将其保持在一个私有列表中。在累积了一定数量 R 个退休节点之后，该线程就扫描其它线程的风险指针，匹配累积节点的地址。如果退休节点没有与任何风险指针匹配，那么释放该节点就是安全的。否则，该线程继续保留该节点，直到它下次扫描这些风险指针。</p><p>By organizing a private list of snapshots of nonnull hazard pointers in a hash table that can be searched in constant expected time, and if the value of R is set such that R &#x3D; H + Ω(H), where H is the total number of hazard pointers, then the methodology is guaranteed in every scan of the hazard pointers to identify Θ(R) nodes as eligible for arbitrary reuse, in O(R) expected time. Thus, the expected amortized time complexity of processing each retired node until it is eligible for reuse is constant.</p><p>通过组织一个私有的非空风险指针的快照的的列表到一个可以以常量预期时间搜索的哈希表中，且如果R设置为满足 R &#x3D; H + Ω(H)，其中 H 是风险指针的总数，那么该方法可以保证在每次扫描风险指针的过程中能识别 Θ(R) 个可任意重用的节点，且能够在 O(R) 预期时间内完成。因此，处理每个退休节点直到它可以被重用的期望分摊时间复杂度是一个常量。</p><p>Note that a small number of hazard pointers per thread can be used to support an arbitrary number of objects as long as that number is sufficient for supporting each object individually. For example, in a program where each thread may operate arbitrarily on hundreds of shared objects that each requires up to two hazard pointers per thread (e.g., hash tables, FIFO queues, LIFO stacks, linked lists, work queues, and priority queues), only a total of two hazard pointers are needed per thread.</p><p>注意，每个线程用很小数量的风险指针就可以用来支持任意数量的对象，只要该数量的风险指针足以能够单独支持每个对象。例如，在一个程序中每个线程可以在数百个共享对象上任意操作，每个对象要求最多每个线程有两个风险指针（例如，哈希表<sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><span class="hint--top hint--rounded" aria-label="O. Shalev and N. Shavit, “Split-Ordered Lists: Lock-Free Extensible Hash Tables,” Proc. 22nd Ann. ACM Symp. Principles of Distributed Computing, pp. 102-111, July 2003.">[25]</span></a></sup>，FIFO队列<sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.">[21]</span></a></sup>，LIFO栈<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>，链表<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.">[16]</span></a></sup>，工作队列<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.">[7]</span></a></sup>，以及优先级队列<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.">[9]</span></a></sup>），那么每个线程总共就只需要两个风险指针。</p><p>Experimental results on an IBM RS&#x2F;6000 multiprocessor system show that the new methodology, applied to lock-free implementations of important object types, offers equal and, more often, significantly better performance than other memory management methods, in addition to its qualitative advantages regarding memory reclamation and independence of special hardware support. We also show that lockfree implementations of important object types, using hazard pointers, offer comparable performance to that of efficient lock-based implementations under no contention and no multiprogramming, and outperform them by significant margins under moderate multiprogramming and&#x2F;or contention, in addition to guaranteeing continuous progress and availability even in the presence of thread failures and arbitrary delays.</p><p>在 IBM RS&#x2F;6000 多处理器系统上的实验结果表明，该新方法当被应用于重要的对象类型的无锁实现时，除了其在内存回收和独立于特殊硬件支持这些质量优势之外，相比于其他内存管理方法，还提供了等同的，或者在更多时候显著更好的性能。我们还表明，使用风险指针（Hazard Pointers）的重要对象类型的无锁实现与高效的基于锁的实现相比，提供了在无争用无多道程序的情况下同等的性能，在中等多道程序和中等争用情况下显著超越他们，此外，甚至在存在的线程失败和任意延迟的情况下，也能保证持续进展和其可用性。</p><p>The rest of this paper is organized as follows: In Section 2, we discuss the computational model for our methodology and memory management issues for lock-free objects. In Section 3, we present the hazard pointer methodology. In Section 4, we discuss applying hazard pointers to lock-free algorithms. In Section 5, we present our experimental performance results. In Section 6, we discuss related work and summarize our results.</p><p>本文的其余部分组织如下：在第 2 节中，我们讨论了方法的计算模型和无锁对象的内存管理问题。在第 3 节中，我们介绍了 hazard pointers 方法。在第 4 节中，我们讨论了将 hazard pointers 应用于无锁算法。在第 5 节中，我们介绍了我们的实验性能结果。在第 6 节中，我们讨论了相关工作并总结了我们的结果。</p><h2 id="2-Preliminaries"><a href="#2-Preliminaries" class="headerlink" title="2.  Preliminaries"></a>2.  Preliminaries</h2><h3 id="2-1-The-Model"><a href="#2-1-The-Model" class="headerlink" title="2.1 The Model"></a>2.1 The Model</h3><p>The basic computational model for our methodology is the asynchronous shared memory model. Formal descriptions of this model appeared in the literature, e.g., <sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “Wait-Free Synchronization,” ACM Trans. Programming Languages and Systems, vol. 13, no. 1, pp. 124-149, Jan. 1991.">[8]</span></a></sup>. Informally, in this model, a set of threads communicate through primitive memory access operations on a set of shared memory locations. Threads run at arbitrary speeds and are subject to arbitrary delays. A thread makes no assumptions about the speed or status of any other thread. That is, it makes no assumptions about whether another thread is active, delayed, or crashed, and the time or duration of its suspension, resumption, or failure. If a thread crashes, it halts execution instantaneously.</p><p>我们的方法的基本计算模型是异步共享内存模型。这个模型的正式描述出现在例如<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “Wait-Free Synchronization,” ACM Trans. Programming Languages and Systems, vol. 13, no. 1, pp. 124-149, Jan. 1991.">[8]</span></a></sup>的文献中。通俗地说，在这个模型中，一组线程通过一组共享内存位置上的原始内存访问操作进行通信。线程以任意速度运行，并受到任意延迟的影响。线程对任何其他线程的速度或状态不作任何假设。也就是说，它不假设另一个线程是活动的、延迟的还是崩溃的，以及其暂停、恢复或失败的时间和长短。如果一个线程崩溃，它会立即停止执行。</p><p>A shared object occupies a set of shared memory locations. An object is an instance of an implementation of an abstract object type, that defines the semantics of allowable operations on the object.</p><p>共享对象占用一组共享内存位置。对象是抽象对象类型的实现的实例，它定义了对象上允许的操作的语义。</p><h3 id="2-2-Atomic-Primitives"><a href="#2-2-Atomic-Primitives" class="headerlink" title="2.2 Atomic Primitives"></a>2.2 Atomic Primitives</h3><p>In addition to atomic reads and writes, primitive operations on shared memory locations may include stronger atomic primitives such as compare-and-swap (CAS) and the pair load-linked&#x2F;store-conditional (LL&#x2F;SC). CAS takes three arguments: the address of a memory location, an expected value, and a new value. If and only if the memory location holds the expected value, the new value is written to it, atomically. A Boolean return value indicates whether the write occurred. That is,  CAS(addr, exp, new) performs the following atomically:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123; <span class="hljs-keyword">if</span> (*addr != <span class="hljs-built_in">exp</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &amp;addr &lt;- <span class="hljs-keyword">new</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br></code></pre></td></tr></table></figure><p>除了原子读取和写入之外，共享内存位置上的原语操作还可能包括更强的原子原语，例如 compare-and-swap（CAS）和成对的 load-linked&#x2F;store -conditional（LL&#x2F;SC）。CAS 有三个参数：内存位置的地址、期望值和新值。当且仅当内存位置保持预期值时，新值将以原子方式写入。布尔返回值指示是否发生写入。即 CAS(addr, exp, new) 原子地执行以下操作：</p><p>除了原子读取和写入，共享内存位置上的基本操作可能包括更强的原子原语，比如 compare-and-swap（CAS）以及 load-linked&#x2F;store-conditional（LL&#x2F; SC）。CAS 有三个参数：内存位置的地址，预期值和新值。当且仅当内存位置保存的是预期值时，新值将以原子方式写入。布尔返回值表示是否发生写入。即 CAS(addr, exp, new) 原子地执行以下操作：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (*addr != <span class="hljs-built_in">exp</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &amp;addr &lt;- <span class="hljs-keyword">new</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br></code></pre></td></tr></table></figure><p>LL takes one argument: the address of a memory location, and returns its contents. SC takes two arguments: the address of a memory location and a new value. Only if no other thread has written the memory location since the current thread last read it using LL, the new value is written to the memory location, atomically. A Boolean return value indicates whether the write occurred. An associated instruction, Validate (VL), takes one argument: the address of a memory location, and returns a Boolean value that indicates whether any other thread has written the memory location since the current thread last read it using LL.</p><p>LL 接收一个参数：内存位置的地址，并返回其内容。SC 接受两个参数：内存位置的地址和新值。仅当自当前线程上次使用 LL 读取内存位置以来没有其他线程写入内存位置时，新值才会原子地写入该内存位置。布尔返回值表示是否发生写入。一个相关的指令， Validate（VL）接收一个参数：内存位置的地址，并返回一个布尔值，该值表示自当前线程上次使用 LL 读取内存位置以来，是否有其他线程写入了该内存位置。</p><p>For practical architectural reasons, none of the architectures that support LL&#x2F;SC (Alpha, MIPS, PowerPC) support VL or the ideal semantics of LL&#x2F;SC as defined above. None allow nesting or interleaving of LL&#x2F;SC pairs, and most prohibit any memory access between LL and SC. Also, all such architectures, occasionally—but not infinitely often—allow SC to fail spuriously; i.e., return false even when the memory location was not written by other threads since it was last read by the current thread using LL. For all the algorithms presented in this paper, CASðaddr; exp; newÞ can be implemented using restricted LL&#x2F;SC as follows:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123; <span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (<span class="hljs-constructor">LL(<span class="hljs-params">addr</span>)</span> != exp) return <span class="hljs-literal">false</span>; &#125; <br>   until <span class="hljs-constructor">SC(<span class="hljs-params">addr</span>, <span class="hljs-params">new</span>)</span>; return truel; &#125;<br></code></pre></td></tr></table></figure><p>出于实际的架构原因，支持 LL&#x2F;SC 的架构（Alpha、MIPS、PowerPC）都不支持 VL 或上面定义的 LL&#x2F;SC 的理想语义。 没有一个架构允许 LL&#x2F;SC 对的嵌套或交织，并且大多数禁止 LL 和 SC 之间的任何内存访问。 此外，所有这些架构偶尔——但不是无限频繁——允许 SC 意外的失败； 即，即使内存位置自上次由当前线程使用 LL 读取后未被其他线程写入，也返回 false。 对于本文提出的所有算法，CAS(addr, exp, new) 可以使用受限制的 LL&#x2F;SC 实现，如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123; <span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (<span class="hljs-constructor">LL(<span class="hljs-params">addr</span>)</span> != exp) return <span class="hljs-literal">false</span>; &#125; <br>   until <span class="hljs-constructor">SC(<span class="hljs-params">addr</span>, <span class="hljs-params">new</span>)</span>; return truel; &#125;<br></code></pre></td></tr></table></figure><p>Most current mainstream processor architectures support either CAS or restricted LL&#x2F;SC on aligned single words. Support for CAS and LL&#x2F;SC on aligned doublewords is available on most 32-bit architectures (i.e., support for 64-bit instructions), but not on 64-bit architecture (i.e., no support for 128-bit instructions).</p><p>当前大多数主流处理器架构都支持对齐单个字的 CAS 或受限 LL&#x2F;SC。 大多数 32 位架构（即支持 64 位指令）支持对齐双字上的 CAS 和 LL&#x2F;SC，但不支持 64 位架构（即不支持 128 位指令）。</p><h3 id="2-3-The-ABA-problem"><a href="#2-3-The-ABA-problem" class="headerlink" title="2.3 The ABA problem"></a>2.3 The ABA problem</h3><p>A different but related problem to memory reclamation is the ABA problem. It affects almost all lock-free algorithms. It was first reported in the documentation of CAS on the IBM System 370. It occurs when a thread reads a value A from a shared location, and then other threads change the location to a different value, say B, and then back to A again. Later, when the original thread checks the location, e.g., using read or CAS, the comparison succeeds, and the thread erroneously proceeds under the assumption that the location has not changed since the thread read it earlier. As a result, the thread may corrupt the object or return a wrong result.</p><p>一个与内存回收不同但相关的问题是 ABA 问题。它影响几乎所有的无锁算法。它首先在 IBM System 370 上的 CAS 文档中被报道。当一个线程从共享位置读取值 A，然后其他线程将该位置更改为不同的值 B，然后再回到 A 时，就会发生这种情况。例如，使用 read 或 CAS，比较结果会成功，线程假设该位置自从线程之前读取它以后并没有改变，从而错误地执行。因此，线程可能会损坏对象或返回错误的结果。</p><p>The ABA problem is a fundamental problem that must be prevented regardless of memory reclamation. Its relation to memory reclamation is that solutions of the latter problem, such as automatic garbage collection (GC) and the new methodology, often prevent the ABA problem as a side-effect with little or no additional overhead.</p><p>ABA 问题是无论内存回收如何都必须防止的基本问题。它与内存回收的关系是内存回收的解决方案，例如自动垃圾收集 (GC) 和这里描述的新方法，通常可以防止 ABA 问题作为副作用而几乎没有额外的开销。</p><p>This is true for most lock-free dynamic objects. But, it should be noted that a common misconception is that GC inherently prevents the ABA problem in all cases. However, consider a program that moves dynamic nodes back and forth between two lists (e.g., LIFO stacks<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>). The ABA problem is possible in such a case, even with perfect GC.</p><p>大多数无锁动态对象都是如此。 但是，应该注意的是，一个常见的误解是 GC 在所有情况下都能从本质上防止 ABA 问题。 然而，考虑一个在两个列表之间来回移动动态节点的程序（例如，LIFO栈<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>）。 ABA 问题在这种情况下是可能存在的，即使是完美的 GC。</p><p>The new methodology is as powerful as GC with respect to ABA prevention in lock-free algorithms. That is, if a lockfree algorithm is ABA-safe under GC, then applying hazard pointers to it makes it ABA-safe without GC. As we discuss in a recent report(M.M. Michael, “ABA Prevention Using Single-Word Instructions”), lock-free algorithms can always be made ABA-safe under GC, as well as using hazard pointers in the absence of GC. In the rest of this paper, when discussing the use of hazard pointers for ABA prevention in the absence of support for GC, we assume that lock-free algorithms are already ABA-safe under GC.</p><p>在无锁算法的 ABA 问题的防止方面，新方法与 GC 一样强大。也就是说，如果一个无锁算法在 GC 下是 ABA 安全的，那么在没有 GC 的情况下对该算法应用风险指针也会使它是 ABA 安全的。正如我们在最近的一份报告<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “ABA Prevention Using Single-Word Instructions,” Technical Report RC 23089, IBM T.J. Watson Research Center, Jan. 2004.">[19]</span></a></sup>中讨论的，无锁算法始终可以在 GC 下实现 ABA 安全，以及在没有 GC 的情况下使用风险指针实现 ABA 安全。在本论文的其余部分，当我们讨论在没有 GC 支持的情况下使用风险指针作为 ABA 防止措施的时候，我们假设该无锁算法在 GC 下已经是 ABA 安全的。</p><h2 id="3-The-Methodlogy"><a href="#3-The-Methodlogy" class="headerlink" title="3. The Methodlogy"></a>3. The Methodlogy</h2><p>The new methodology is primarily based on the observation that, in the vast majority of algorithms for lock-free dynamic objects, a thread holds only a small number of references that may later be used without further validation for accessing the contents of dynamic nodes, or as targets or expected values of ABA-prone atomic comparison operations.</p><p>该新方法主要是根据观察发现，在绝大多数无锁动态对象算法中，线程只会持有少量的引用，这些引用稍后可能会在没有进一步验证访问动态节点的内容的情况下使用，或者作为易于发生ABA问题（ABA-prone）的原子比较操作的目标或期望值。</p><p>The core idea of the new methodology is associating a number of single-writer multireader shared pointers, called hazard pointers, with each thread that may operate on the associated objects. The number of hazard pointers per thread depends on the algorithms for associated objects and may vary among threads depending on the types of objects they intend to access. Typically, this number is one or two. For simplicity of presentation, we assume that each thread has the same number K of hazard pointers.</p><p>新方法的核心思想是，将一些被称为风险指针（hazard pointers）的单写者多读者（single-writer multi-reader）的共享指针，与每一个想要访问相关对象的线程关联起来。每个线程的风险指针的数量取决于相关联的对象的算法，且根据他们打算访问的对象的类型不同可能会有所不同。通常情况下，这个数目是 1 个或 2 个。为简单起见，我们假定每个线程都具有相同的 K 个风险指针（hazard pointers）。</p><p>The methodology communicates with the associated algorithms only through hazard pointers and a procedure RetireNode that is called by threads to pass the addresses of retired nodes. The methodology consists of two main parts: the algorithm for processing retired nodes, and the condition that lock-free algorithms must satisfy in order to guarantee the safety of memory reclamation and ABA prevention.</p><p>该方法只通过风险指针（hazard pointers）和一个被称为 RetireNode 的过程（线程通过它传递退休节点的地址）来与相关的算法通信。该方法包括两个主要部分：处理退休节点的算法，以及无锁算法为了保证内存回收的安全性和防止 ABA 问题所必须满足的条件。</p><h3 id="3-1-The-Algorithm"><a href="#3-1-The-Algorithm" class="headerlink" title="3.1 The Algorithm"></a>3.1 The Algorithm</h3><img src="/2023/01/08/hazard-pointers/Fig-1.png" class=""><p>Fig. 1 shows the shared and private structures used by the algorithm. The main shared structure is the list of hazard pointer (HP) records. The list is initialized to contain one HP record for each of the N participating threads. The total number of hazard pointers is H &#x3D; NK[^R]. Each thread uses two static private variables, rlist (retired list) and rcount (retired count), to maintain a private list of retired nodes.</p><p>图 1 显示出该算法所使用的共享和私有结构。主要的共享结构是风险指针（HP）记录的列表。该列表被初始化为给 N 个参与线程的每一个都包含一个HP 记录。风险指针的总数是 H&#x3D;NK [^R]。每个线程使用了两个静态的私有变量，rlist（退休列表）和 rcount（退休计数），以保持私有的退休节点列表。</p><img src="/2023/01/08/hazard-pointers/Fig-2.png" class=""><p>Fig. 2 shows the RetireNode routine, where the retired node is inserted into the thread’s list of retired nodes and the length of the list is updated. Whenever the size of a thread’s list of retired nodes reaches a threshold R, the thread scans the list of hazard pointers using the Scan routine. R can be chosen arbitrarily. However, in order to achieve a constant expected amortized processing time per retired node, R must satisfy R &#x3D; H + Ω(H).</p><p>图 2 所示的 RetireNode 例程，其中退休节点插入线程的退休节点的列表，并更新列表的长度。每当线程的退休的节点列表的大小达到阈值 R，线程就使用 Scan 例程扫描风险指针（hazard pointers）列表。 R 可以是任意选择的。然而，为了每个退休节点达到一个常量的预期分摊处理时间，R 必须满足 R &#x3D; H + Ω(H)。</p><img src="/2023/01/08/hazard-pointers/Fig-3.png" class=""><p>Fig. 3 shows the Scan routine. A scan consists of two stages. The first stage involves scanning the HP list for nonnull values. Whenever a nonnull value is encountered, it is inserted in a local list plist, which can be implemented as a hash table. The second stage of Scan involves checking each node in rlist against the pointers in plist. If the lookup yields no match, the node is identified to be ready for arbitrary reuse. Otherwise, it is retained in rlist until the next scan by the current thread. Insertion and lookup in plist take constant expected time.</p><p>图 3 示出了 Scan 例程。扫描分为两个阶段。第一阶段包括扫描 HP 列表获得所有非空值。每当遇到非空值时，它被插入在一个本地列表 plist 中，这可以被实现为一个哈希表。扫描的第二阶段涉及检查 rlist 中的每个节点对比 plist 中的指针。如果查找返回不匹配，该节点就被确定为可以任意重用。否则，它被保留在 rlist 中，直到当前线程进行下一次扫描。在 plist 中的插入和查询需要常量的预期时间复杂度。</p><p>Alternatively, if a lower worst-case—instead of average— time complexity is desired, plist can be implemented as a balanced search tree with O(log p) insertion and lookup time complexities, where p is the number of nonnull hazard pointers encountered in Stage 1 of Scan. In such a case, the amortized time complexity per retired node is O(log p).</p><p>或者，如果期望更低的最坏情况时间复杂度，而不是平均时间复杂度，plist 可以被实现为一个平衡搜索树，这样插入和查找时间复杂度为 O(log p)，其中 p 是在阶段 1 扫描中所遇到的非空风险指针（hazard pointers）的数目。在这种情况下，每个退休节点的分摊时间复杂度是 O(log p)。</p><p>In practice, for simplicity and speed, we recommend implementing plist as an array and sorting it at the end of Stage 1 of Scan, and then using binary search in Stage 2. We use the latter implementation for our experiments in Section 5. We omit the algorithms for hash tables, balanced search trees, sorting, and binary search, as they are wellknown sequential algorithms <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.H. Cormen, C.E. Leiserson, and R.L. Rivest, Introduction to Algorithms. MIT Press, 1990.">[2]</span></a></sup>.</p><p>在实践中，为了简单性和速度，我们建议将 plist 实现为一个数组，且在扫描的第一阶段结束时排序，然后在第二阶段使用二分查找。在第 5 节中，我们使用后者来实现我们的实验。我们省略了哈希表、平衡搜索树、排序和二分查找算法，因为它们是知名的顺序算法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.H. Cormen, C.E. Leiserson, and R.L. Rivest, Introduction to Algorithms. MIT Press, 1990.">[2]</span></a></sup>。</p><p>The task of the memory reclamation method in the context of this paper is to determine when a retired node is eligible for reuse safely while allowing memory reclamation. Thus, the definition of the PrepareF orReuse routine is open for several implementation options and is not an integral part of this methodology. An obvious implementation of that routine is to reclaim the node immediately for arbitrary reuse using the standard library call for memory deallocation, e.g., free. Another possibility—in order to reduce the overhead of calling malloc and free for every node allocation and deallocation—is that each thread can maintain a limited size private list of free nodes. When a thread runs out of private free nodes, it allocates new nodes, and when it accumulates too many private free nodes, it deallocates the excess nodes.</p><p>在本论文的上下文中，内存回收方法的任务是，在允许内存回收时，确定一个退休节点何时可以安全地被重用。因此，PrepareForReuse 例程的定义是开放的，可以有几个备选实现方案，因此它就不是我们这里所提方法的一个不可分割的一部分。该例程的一个明显实现是立即使用标准库函数调用，例如 free，来释放内存回收节点，以作任意重用。另一种可能性，为了减少每个节点分配和释放都调用 malloc 和 free 的开销，每个线程都可以维持一个大小有限的私有的 free 节点列表。当线程用完了私有 free 节点，它就分配新节点，当它积累了太多的私有 free 节点时，它就释放多余的节点。</p><p>The algorithm is wait-free; it takes O(R) expected time—or O(R log p) worst-case time if a logarithmic search structure is used—to identify Θ(R) retired nodes as eligible for arbitrary reuse. It only uses single-word reads and writes. It offers an upper bound NR on the number of retired nodes that are not yet eligible for reuse, even if some or all threads are delayed or have crashed.</p><p>该算法是无等待的（wait-free），它需要 O(R) 的预期时间或 O(R log p) 的最坏情况下的时间（如果使用了对数搜索结构来识别  Θ(R) 个可以任意重用的退休节点)。它仅使用单字内存读取和写入操作。它提供了一个还不能重用的退休节点的上限个数 NR，即使部分或全部线程被延迟或已经崩溃。</p><h3 id="3-2-Algorithm-Extensions"><a href="#3-2-Algorithm-Extensions" class="headerlink" title="3.2 Algorithm Extensions"></a>3.2 Algorithm Extensions</h3><p>The following are optional extensions to the core algorithm that enhance the methodology’s flexibility.</p><p>以下是核心算法的可选扩展，提高了该方法的灵活性。</p><p>If the maximum number N of participating threads is not known before hand, we can add new HP records to the HP list using a simple push routine <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>. Note that such a routine is wait-free, as the maximum number of threads is finite. This can be useful also, if it is desirable for threads to be able to allocate additional hazard pointers dynamically.</p><p>如果事先不知道参与线程的最大数量 N，我们可以使用一个简单的 push 例程来添加新的 HP 记录到 HP 列表<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>。需要注意的是，这样的程序是无等待的（wait-free），因为最大线程数是有限的。如果线程想要能够动态分配额外的风险指针（hazard pointers），这种方法也可能是有用的。</p><p>In some applications, threads are created and retired dynamically. In such cases, it is desirable to allow HP records to be reused. Adding a Boolean flag to each HP record can serve as an indicator if the HP record is in use or available for reuse. Before retiring, a thread can clear the flag, and when a new thread is created, it can search the HP list for an available HP record and acquire it using test-andset (TAS). If no HP records are available, a new one can be added as described above.</p><p>在某些应用程序中，线程是动态创建和退出的。 在这种情况下，允许重复使用 HP 记录是可取的。为每个 HP 记录添加一个布尔型标志（Boolean flag），可以作为说明是否 HP 记录正在使用或可以重用的指示器。线程退出之前，可以清除该标志，当创建一个新线程时，可以搜索 HP 记录列表，找到一个可用的 HP 记录，并 test-and-set(TAS) 获得它。如果没有 HP 记录是可用的，可以按如上所述的方法添加一个新的。</p><p>Since a thread may have leftover retired nodes not yet identified as eligible for reuse, two fields can be added to the HP record structure so that a retiring thread can pass the values of its rlist and rcount variables to the next thread that inherits the HP record.</p><p>由于线程可能有剩余的退休节点尚未被识别为可以被重用，可以添加两个字段到 HP 记录结构体中，使得退休线程可以传递 rlist 和 rcount 变量的值给下一个继承该 HP 记录的线程。</p><p>Furthermore, it may be desirable to guarantee that every node that is eligible for reuse is eventually freed, barring thread failures. To do so, after executing Scan, a thread executes a HelpScan, where it checks every HP record. If an HP record is inactive, the thread locks it using TAS and pops nodes from its rlist. Whenever, the thread accumulates R nodes, it performs a Scan. Therefore, even if a thread retires leaving behind an HP record with a nonempty rlist and its HP record happens not to be reused, the nodes in the rlist will still be processed by other threads performing HelpScan.</p><p>此外，可能需要保证每个可以被重用的节点最终都被释放，除非线程失败。要做到这一点，在执行 Scan 后，线程再执行一个 HelpScan，它会检查每个 HP 记录。如果有 HP 记录是不活动的（inactive），线程将其使用 TAS 锁定，并从其 rlist 中弹出（pop）节点。每当线程积累 R 个节点，就执行执行一次 Scan。因此，即使一个线程退出时留下了一个具有非空 rlist 的 HP 记录，而其 HP 记录恰巧没有被重用，rlist 中的节点仍然可以被其他执行  HelpScan 的线程处理。</p><img src="/2023/01/08/hazard-pointers/Fig-4.png" class=""><p>Fig. 4 shows a version of the algorithm that incorporates the above mentioned extensions. The algorithm is still waitfree, and only single-word instructions are used.</p><p>图 4 显示了包含上述扩展的算法版本。 该算法仍然是无等待（wait-free）的，并且只使用单字指令。</p><h3 id="3-3-The-Condition"><a href="#3-3-The-Condition" class="headerlink" title="3.3 The Condition"></a>3.3 The Condition</h3><p>For a correct algorithm for a dynamic lock-free object to use the new methodology for memory reclamation and ABA prevention, it must satisfy a certain condition. When a thread assigns a reference (i.e., a node’s address) to one of its hazard pointers, it basically announces to other threads that it may use that reference in a hazardous manner (e.g., access the contents of the node without further validation of the reference), so that other threads will refrain from reclaiming or reusing the node until the reference is no longer hazardous. This announcement (i.e., setting the hazard pointer) must take place before the node is retired and the hazard pointer must continue to hold that reference until the reference is no longer hazardous.</p><p>对于一个正确的算法，为了动态无锁对象能使用新的方法来做内存回收和防止 ABA 问题，它必须满足一定的条件。当线程分配一个引用（即，一个节点的地址）到它的一个风险指针（hazard pointer）时，它基本上是在向其他线程宣布，它可能要以有风险的方式（hazardous manner）使用该引用（例如，访问节点的内容而没有进一步的验证该引用），这样，其他线程将避免回收或再重用该节点，直到该引用不再是有风险的（hazardous）。这一宣告（即设置风险指针，hazard pointer）必须在此节点退休之前，且风险指针（hazard pointer）必须持续持有该引用，直到引用不再是有风险的（hazardous）。</p><p>For a formal description of the condition, we first define some terms:</p><p>为正式描述该条件，我们先定义一些术语：</p><p>Node: We use the term node to describe a range of memory locations that at some time may be viewed as a logical entity either through its actual use in an object that uses hazard pointers, or from the point of view of a participating thread. Thus, it is possible for multiple nodes to overlap physically, but still be viewed as distinct logical entities.</p><p>节点（Node）：我们使用术语节点来描述一个内存位置范围，有时可以通过其在使用风险指针的对象中的实际使用，或从参与线程的角度将其视为逻辑实体。 因此，多个节点有可能在物理上重叠，但仍被视为不同的逻辑实体。</p><p>At any time t, each node n is in one of the following states:</p><ol><li>Allocated: n is allocated by a participating thread, but not yet inserted in an associated object.</li><li>Reachable: n is reachable by following valid pointers starting from the roots of an associated object.</li><li>Removed: n is no longer reachable, but may still be in use by the removing thread.</li><li>Retired: n is already removed and consumed by the removing thread, but not yet free.</li><li>Free: n’s memory is available for allocation.</li><li>Unavailable: all or part of n’s memory is used by an unrelated object.</li><li>Undefined: n’s range of memory locations is not currently viewed as a node.</li></ol><p>在任一时刻 t，每个节点 n 处于下列状态之一：</p><ol><li>已分配（Allocated）： n 被一个参与线程分配，但尚未插入到一个相关联的对象。</li><li>可到达（Reachable）：n 可以通过跟踪从关联对象的根开始的有效指针到达。</li><li>已删除（Removed）：n 不再可到达，但仍可能在删除线程（removing thread）中正被使用。</li><li>已退休（Retired）： n 已经被删除线程删除并使用，但还没有释放。</li><li>空闲（Free）：n 的内存可以被分配使用。</li><li>不可用（Unavailable）：n 的部分或全部内存被一个不相干的对象在使用。</li><li>未定义（Undefined）：n 的内存位置范围目前不被视为一个节点。</li></ol><p>Own: A thread j owns a node n at time t, iff at t, n is allocated, removed, or retired by j. Each node can have at most one owner. The owner of an allocated node is the thread that allocated it (e.g., by calling malloc). The owner of a removed node is the thread that executed the step that removed it from the object (i.e., changed its state from reachable to removed). The owner of a retired node is the same one that removed it.</p><p>拥有（Own）：线程 j 在时间 t 拥有节点 n，当且仅当在 t，n 被 j 分配、删除或退休。 每个节点最多可以有一个所有者。被分配的（allocated）节点的拥有者（owner）是分配它的线程（例如，通过调用 malloc）。被删除的（removed）节点的拥有者（owner）是执行将它从对象中删除步骤的线程（也即，将其状态从可到达（reachable）改为已删除（removed））。已退休（retired）节点的拥有者（owner）与删除它的线程是同一个线程。</p><p>Safe: A node n is safe for a thread j at time t, iff at time t, either n is reachable, or j owns n.</p><p>安全的（safe）：节点 n 在时间 t 对线程 j 是安全的，当且仅当在时间 t，要么 n 可达，要么 j 拥有 n。</p><p>Possibly unsafe: A node is possibly unsafe at time t from the point of view of thread j, if it is impossible solely by examining j’s private variables and the semantics of the algorithm to determine definitely in the affirmative that at time t the node is safe for j.</p><p>可能不安全的（Possibly unsafe）：从线程 j 的角度来看，节点在时间 t 可能不安全，如果仅通过检查 j 的私有变量和算法的语义，对于线程 j，不可能肯定地确定节点在时间 t 是安全的。</p><p>Access hazard: A step s in thread j’s algorithm is an access hazard iff it may result in access to a node that is possibly unsafe for j at the time of its execution.</p><p>访问风险（Access hazard）：线程 j 算法中的步骤 s 是访问风险，当且仅当它可能导致访问在执行时对 j 来说可能不安全的节点。</p><p>ABA hazard: A step s in thread j’s algorithm is an ABA hazard iff it includes an ABA-prone comparison that involves a dynamic node that is possibly unsafe for j at the time of the execution of s, such that either 1) the node’s address—or an arithmetic variation of it—is an expected value of the ABA-prone comparison, or 2) a memory location contained in the dynamic node is the target of the ABA-prone comparison.</p><p>ABA 风险（ABA hazard）：线程 j 算法中的步骤 s 是一个 ABA 风险，当且仅当它包含一个 ABA 问题的比较（ABA-prone comparison）操作，该比较操作涉及一个在执行 s 时可能对 j 不安全的动态节点，例如 1) 节点的地址或其算术变体，是容易发生 ABA 问题的比较（ABA-prone comparison）操作的一个预期值，或 2) 动态节点中包含的内存位置是容易发生 ABA 问题的比较（ABA-prone comparison）操作的目标。</p><p>Access-hazardous reference: A thread j holds an accesshazardous reference to a node n at time t, iff at time t one or more of j’s private variables holds n’s address or an arithmetic variation of it, and j is guaranteed—unless it crashes—to reach an access hazard s that uses n’s address hazardously, i.e., accesses n when n is possibly unsafe for j.</p><p>有访问风险的引用（Access-hazardous reference）：线程 j 在时刻 t 持有对节点 n 的有访问风险的引用（accesshazardous reference），当且仅当在时刻 t，j 的一个或多个私有变量持有 n 的地址或其算术变体，并且保证 j（除非它崩溃）达到访问风险（access hazard）s，在那里风险地使用 n 的地址，即当 n 对 j 可能不安全（possibly unsafe）时访问 n。（存在一个引用，肯定能到达，但是一旦访问就有风险。）</p><p>ABA-hazardous reference: A thread j holds an ABAhazardous reference to a node n at time t, iff at time t, one or more of j’s private variables holds n’s address or a mathematical variation of it, and j is guaranteed—unless it crashes—to reach an ABA hazard s that uses n’s address hazardously.</p><p>有 ABA 风险的引用（ABA-hazardous reference）：线程 j 在时刻 t 包含对节点 n 的一个有 ABA 风险的引用（ABA-hazardousreference），当且仅当在时刻 t，j 的一个或者多个私有变量持有 n 的地址，或者其算数变体，并且 j 可以保证（除非它崩溃了）能够到达 ABA 风险（ABA hazard）s，在那里有风险地使用 n 的地址。</p><p>Hazardous reference: A reference is hazardous if it is accesshazardous and&#x2F;or ABA-hazardous.</p><p>有风险的引用（Hazardous reference）：一个引用是有风险的，如果它有访问风险（access-hazardous），和&#x2F;或者有ABA风险（ABA-hazardous）。</p><p>Informally, a hazardous reference is an address that without further validation of safety will be used later in a hazardous manner, i.e., to access possibly unsafe memory and&#x2F;or as a target address or an expected value of an ABA-prone comparison.</p><p>非正式地，风险引用是一个地址，如果没有进一步的安全验证，以后将以存在风险的方式使用它，即访问可能不安全的内存和&#x2F;或作为目标地址或容易发生 ABA 问题的比较（ABA-prone comparison）操作的预期值。</p><p>A thread that holds a reference to a node uses hazard pointers to announce to other threads that it may use the reference later without further validation in a hazardous step. However, this announcement is useless if it happens after the reference is already hazardous, or in other words, after the node is possibly unsafe, since another thread might have already removed the node, and then scanned the HP list and found no match for that node. Therefore, the condition that an associated algorithm must satisfy is that whenever a thread is holding a hazardous reference to a node, it must be the case that at least one of the thread’s hazard pointers has been continuously holding that reference from a time when the node was definitely safe for the thread. Note that this condition implies that no thread can create a new hazardous reference to a node while it is retired.</p><p>一个持有节点的引用的线程，使用风险指针（hazard pointers）来向其他线程宣告，之后在一个有风险的步骤中，它可以使用该引用，而不做进一步验证。然而，如果该宣告发生在该引用已经是有风险的之后，或者换句话说，在节点可能是不安全的（possibly unsafe）之后，那么此宣告是无用的，因为另一个线程可能已经删除了该节点，且接着扫描了 HP 列表，而没有找到与那个节点匹配的节点。因此，相关联的算法必须满足的条件是，每当线程持有到一个节点的存在风险的引用时，它的情况必须是，线程的风险指针中的至少一个，已经从该节点对线程绝对安全的时候开始，持续持有该引用。注意，这种情况意味着，没有任何线程能够在它退休后创建一个新的对一个节点的有风险的引用。</p><p>Formally, the condition is as follows, where HPj is the set of thread j’s hazard pointers:</p><img src="/2023/01/08/hazard-pointers/Fig.png" class=""><p>正式地，条件如下，其中 HPj 是线程 j 的风险指针集：</p><img src="/2023/01/08/hazard-pointers/Fig.png" class=""><h3 id="3-4-Correctness"><a href="#3-4-Correctness" class="headerlink" title="3.4 Correctness"></a>3.4 Correctness</h3><p>Omit</p><h2 id="4-Applying-Hazard-Pointers"><a href="#4-Applying-Hazard-Pointers" class="headerlink" title="4. Applying Hazard Pointers"></a>4. Applying Hazard Pointers</h2><p>This section discusses the methodology for adapting existing lock-free algorithms to the condition in Section 3.3. The following is an outline:</p><p>本节讨论将现有的无锁算法适配到在 3.3 节中的条件的方法。以下是大纲：</p><ol><li><p>Examine the target algorithm as follows:</p><ul><li>Identify hazards and the hazardous references they use.</li><li>For each distinct hazardous reference, determine the point where it is created and the last hazard that uses it. The period between these two points is when a hazard pointer needs to be dedicated to that reference.</li><li>Compare the periods determined in the previous step for all hazardous references, and determine the maximum number of distinct references that can be hazardous—for the same thread—at the same time. This is the maximum number of hazard pointers needed per thread.</li></ul></li><li><p>For each hazardous reference, insert the following steps in the target algorithm after the creation of the reference and before any of the hazards that use it:</p><ul><li>Write the address of the node that is the target of the reference to an available hazard pointer.</li><li>Validate that the node is safe. If the validation succeeds, follow the normal flow of control of the target algorithm. Otherwise, skip over the hazards and follow the path of the target algorithm when conflict is detected, i.e., try again, backoff, exit loop, etc. This step is needed, as the node might have been already removed before the previous step was executed.</li></ul></li><li><p>按如下所示检查目标算法：</p><ul><li>识别它们涉及的风险（hazards）以及存在风险的引用（hazardous references）。</li><li>对于每一个不同的存在风险的引用（hazardous reference），确定它是在何时被创建的，以及使用该引用的最后风险（last hazard）是在何时。这两点之间的间隔就是需要为该引用设定专用的风险指针（hazard pointer）的时间。</li><li>对所有存在风险的引用（hazardous references），对比在前面的步骤中得到的间隔，并确定对相同线程同一时间可能有风险（hazardous）的不同引用的最大数目。这就是每个线程需要的风险指针（hazard pointers）的最大数目。</li></ul></li><li><p>对于每个有风险的引用（hazardous reference），在创建引用之后，并在任何使用到该引用的风险之前，将下面的步骤插入到目标算法中：</p><ul><li>将引用目标节点的地址写入一个可用的风险指针中。</li><li>验证该节点是安全的。如果验证成功，按照目标算法的正常控制流程继续。否则，跳过风险（hazards），并按照目标算法在检测到冲突时的路径继续，即，重试，后退，退出循环，等等。这一步是必要的，因为节点可能在执行前一步之前已经删除。</li></ul></li></ol><p>We applied hazard pointers to many algorithms, e.g., <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>, <sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.">[9]</span></a></sup>, <sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="S. Prakash, Y.-H. Lee, and T. Johnson, “A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap,” IEEE Trans. Computers, vol. 43, no. 5, pp. 548-559, May 1994.">[23]</span></a></sup>, <sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><span class="hint--top hint--rounded" aria-label="J. Turek, D. Shasha, and S. Prakash, “Locking Without Blocking: Making Lock Based Concurrent Data Structure Algorithms Nonblocking,” Proc. 11th ACM Symp. Principles of Database Systems, pp. 212-222, June 1992.">[28]</span></a></sup>, <sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.">[21]</span></a></sup>, <sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><span class="hint--top hint--rounded" aria-label="N. Shavit and D. Touitou, “Software Transactional Memory,” Distributed Computing, vol. 10, no. 2, pp. 99-116, 1997.">[26]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.">[16]</span></a></sup>, <sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.">[7]</span></a></sup>, <sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, K. Fraser, and I.A. Pratt, “A Practical Multi-Word Compare-and-Swap Operation,” Proc. 16th Int’l Symp. Distributed Computing, pp. 265-279, Oct. 2002.">[6]</span></a></sup>, <sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “CAS-Based Lock-Free Algorithm for Shared Deques,” Proc. Ninth Euro-Par Conf. Parallel Processing, pp. 651- 660, Aug. 2003.">[18]</span></a></sup>, for the purposes of allowing memory reclamation and ABA prevention. We use several algorithms for important object types to demonstrate the application of the steps described above.</p><p>我们应用了风险指针到很多算法中，例如 <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup>, <sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.">[9]</span></a></sup>, <sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="S. Prakash, Y.-H. Lee, and T. Johnson, “A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap,” IEEE Trans. Computers, vol. 43, no. 5, pp. 548-559, May 1994.">[23]</span></a></sup>, <sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><span class="hint--top hint--rounded" aria-label="J. Turek, D. Shasha, and S. Prakash, “Locking Without Blocking: Making Lock Based Concurrent Data Structure Algorithms Nonblocking,” Proc. 11th ACM Symp. Principles of Database Systems, pp. 212-222, June 1992.">[28]</span></a></sup>, <sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.">[21]</span></a></sup>, <sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><span class="hint--top hint--rounded" aria-label="N. Shavit and D. Touitou, “Software Transactional Memory,” Distributed Computing, vol. 10, no. 2, pp. 99-116, 1997.">[26]</span></a></sup>, <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.">[4]</span></a></sup>, <sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.">[16]</span></a></sup>, <sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.">[7]</span></a></sup>, <sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="T.L. Harris, K. Fraser, and I.A. Pratt, “A Practical Multi-Word Compare-and-Swap Operation,” Proc. 16th Int’l Symp. Distributed Computing, pp. 265-279, Oct. 2002.">[6]</span></a></sup>, <sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="M.M. Michael, “CAS-Based Lock-Free Algorithm for Shared Deques,” Proc. Ninth Euro-Par Conf. Parallel Processing, pp. 651- 660, Aug. 2003.">[18]</span></a></sup>，用以允许内存回收和防止 ABA 问题。我们使用了几个重要的对象类型的算法，来展示上述步骤的应用。</p><p>Note that, while applying these steps is easy for algorithm designers, these steps are not readily applicable automatically (e.g., by a compiler). For example, it is not clear if a compiler can determine if a node is no longer reachable. Identifying ABA hazards is even more challenging for a compiler, as the ABA problem is a subtle problem that involves the implicit intentions of the algorithm designer.</p><p>请注意，虽然应用这些步骤对算法设计者来说很容易，这些步骤并不是很容易自动地适用（例如，编译器）。例如，目前尚不清楚，是否编译器可以判断是否一个节点不再可达。识别 ABA 风险对于编译器更具挑战性，因为 ABA 问题是一个微妙的问题，涉及算法设计者的隐含意图。</p><h3 id="4-1-FIFO-Queues"><a href="#4-1-FIFO-Queues" class="headerlink" title="4.1 FIFO Queues"></a>4.1 FIFO Queues</h3><p>Omit</p><h3 id="4-2-LIFO-Stacks"><a href="#4-2-LIFO-Stacks" class="headerlink" title="4.2 LIFO Stacks"></a>4.2 LIFO Stacks</h3><img src="/2023/01/08/hazard-pointers/Fig-8.png" class=""><p>Fig. 8 shows a lock-free stack based on the IBM freelist algorithm <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup> augmented with hazard pointers. In the push routine, the node accesses in lines 2 and 4 are not hazardous (as *node is owned by the thread at the time), and the CAS in line 5 is not ABA-prone (as the change of Top between lines 3 and 5 can never lead to corrupting the stack or any other object). Thus, no hazard pointers are needed for the push routine.</p><p>图 8 显示了一个基于 IBM freelist 算法 <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.">[11]</span></a></sup> 的无锁栈，并使用了风险指针。 在 push 例程中，第 2 行和第 4 行中的节点访问没有风险（因为 *node 在那时候被该线程拥有），第 5 行中的 CAS 不是 ABA 易发的（因为在第 3 行和第 5 行之间改变 Top 永远不会导致破坏栈或任何其他对象）。 因此，push 例程不需要风险指针（hazard pointers）。</p><p>In the pop routine, the node access in line 10 is hazardous and the CAS in line 11 is ABA-prone. All hazards use the reference t. The technique employed in transforming the pop routine is the same as that used in the enqueue routine of Fig. 6.</p><p>在 pop 例程中，第 10 行的节点访问是存在风险（hazardous）的，第 11 行的 CAS 是 ABA 易发的。 所有的风险都使用引用 t。 用于转化 pop 例程的技术与图 6 的 enqueue 例程中使用的技术相同。</p><h3 id="4-3-List-Based-Sets-and-Hash-Tables"><a href="#4-3-List-Based-Sets-and-Hash-Tables" class="headerlink" title="4.3 List-Based Sets and Hash Tables"></a>4.3 List-Based Sets and Hash Tables</h3><p>Omit</p><h3 id="4-4-Single-Writer-Multireader-Dynamic-Structures"><a href="#4-4-Single-Writer-Multireader-Dynamic-Structures" class="headerlink" title="4.4 Single-Writer Multireader Dynamic Structures"></a>4.4 Single-Writer Multireader Dynamic Structures</h3><p>Omit</p><h2 id="5-Experimental-Performance-Results"><a href="#5-Experimental-Performance-Results" class="headerlink" title="5. Experimental Performance Results"></a>5. Experimental Performance Results</h2><p>omit</p><h2 id="6-Discussion"><a href="#6-Discussion" class="headerlink" title="6. Discussion"></a>6. Discussion</h2><h3 id="6-1-Related-Work"><a href="#6-1-Related-Work" class="headerlink" title="6.1 Related Work"></a>6.1 Related Work</h3><h4 id="6-1-1-IBM-ABA-Prevention-Tags"><a href="#6-1-1-IBM-ABA-Prevention-Tags" class="headerlink" title="6.1.1 IBM ABA-Prevention Tags"></a>6.1.1 IBM ABA-Prevention Tags</h4><p>Omit</p><h4 id="6-1-2-Lock-Free-Reference-Counting"><a href="#6-1-2-Lock-Free-Reference-Counting" class="headerlink" title="6.1.2 Lock-Free Reference Counting"></a>6.1.2 Lock-Free Reference Counting</h4><p>Omit</p><h4 id="6-1-3-Scheduler-Dependent-and-Blocking-Methods"><a href="#6-1-3-Scheduler-Dependent-and-Blocking-Methods" class="headerlink" title="6.1.3 Scheduler-Dependent and Blocking Methods"></a>6.1.3 Scheduler-Dependent and Blocking Methods</h4><p>Omit</p><h4 id="6-1-4-Recent-Work"><a href="#6-1-4-Recent-Work" class="headerlink" title="6.1.4 Recent Work"></a>6.1.4 Recent Work</h4><p>Omit</p><h3 id="6-2-Conclusions"><a href="#6-2-Conclusions" class="headerlink" title="6.2 Conclusions"></a>6.2 Conclusions</h3><p>Omit</p><h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Omit</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[^R]: As discussed in Section 3.2, the algorithm can be extended such that the values of N and H do not need to be known in advance, and threads can join and leave the system dynamically and allocate and deallocate hazard pointers dynamically.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span>T.H. Cormen, C.E. Leiserson, and R.L. Rivest, Introduction to Algorithms. MIT Press, 1990.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>D.L. Detlefs, P.A. Martin, M. Moir, and G.L. Steele Jr., “Lock-Free Reference Counting,” Proc. 20th Ann. ACM Symp. Principles of Distributed Computing, pp. 190-199, Aug. 2001.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>M.B. Greenwald, “Non-Blocking Synchronization and System Design,” PhD thesis, Stanford Univ., Aug. 1999.<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>T.L. Harris, “A Pragmatic Implementation of Non-Blocking Linked Lists,” Proc. 15th Int’l Symp. Distributed Computing, pp.*nbsp;300-314, Oct. 2001.<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>T.L. Harris, K. Fraser, and I.A. Pratt, “A Practical Multi-Word Compare-and-Swap Operation,” Proc. 16th Int’l Symp. Distributed Computing, pp. 265-279, Oct. 2002.<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>D. Hendler and N. Shavit, “Work Dealing,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 164-172, Aug. 2002.<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>M.P. Herlihy, “Wait-Free Synchronization,” ACM Trans. Programming Languages and Systems, vol. 13, no. 1, pp. 124-149, Jan. 1991.<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>M.P. Herlihy, “A Methodology for Implementing Highly Concurrent Objects,” ACM Trans. Programming Languages and Systems, vol. 15, no. 5, pp. 745-770, Nov. 1993.<a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>M.P. Herlihy, V. Luchangco, and M. Moir, “The Repeat Offender Problem: A Mechanism for Supporting Dynamic-Sized Lock-Free Data Structures,” Proc. 16th Int’l Symp. Distributed Computing, pp. 339-353, Oct. 2002.<a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>IBM, IBM System&#x2F;370 Extended Architecture, Principles of Operation, publication no. SA22-7085, 1983.<a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:13" class="footnote-text"><span>P.E. McKenney and J.D. Slingwine, “Read-Copy Update: Using Execution History to Solve Concurrency Problems,” Proc. 10th IASTED Int’l Conf. Parallel and Distributed Computing and Systems, Oct. 1998.<a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:16" class="footnote-text"><span>M.M. Michael, “High Performance Dynamic Lock-Free Hash Tables and List-Based Sets,” Proc. 14th Ann. ACM Symp. Parallel Algorithms and Architectures, pp. 73-82, Aug. 2002.<a href="#fnref:16" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:18" class="footnote-text"><span>M.M. Michael, “CAS-Based Lock-Free Algorithm for Shared Deques,” Proc. Ninth Euro-Par Conf. Parallel Processing, pp. 651- 660, Aug. 2003.<a href="#fnref:18" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:19" class="footnote-text"><span>M.M. Michael, “ABA Prevention Using Single-Word Instructions,” Technical Report RC 23089, IBM T.J. Watson Research Center, Jan. 2004.<a href="#fnref:19" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:21" class="footnote-text"><span>M.M. Michael and M.L. Scott, “Simple, Fast, and Practical NonBlocking and Blocking Concurrent Queue Algorithms,” Proc. 15th Ann. ACM Symp. Principles of Distributed Computing, pp. 267-275, May 1996.<a href="#fnref:21" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:23" class="footnote-text"><span>S. Prakash, Y.-H. Lee, and T. Johnson, “A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap,” IEEE Trans. Computers, vol. 43, no. 5, pp. 548-559, May 1994.<a href="#fnref:23" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:25" class="footnote-text"><span>O. Shalev and N. Shavit, “Split-Ordered Lists: Lock-Free Extensible Hash Tables,” Proc. 22nd Ann. ACM Symp. Principles of Distributed Computing, pp. 102-111, July 2003.<a href="#fnref:25" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:26" class="footnote-text"><span>N. Shavit and D. Touitou, “Software Transactional Memory,” Distributed Computing, vol. 10, no. 2, pp. 99-116, 1997.<a href="#fnref:26" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:28" class="footnote-text"><span>J. Turek, D. Shasha, and S. Prakash, “Locking Without Blocking: Making Lock Based Concurrent Data Structure Algorithms Nonblocking,” Proc. 11th ACM Symp. Principles of Database Systems, pp. 212-222, June 1992.<a href="#fnref:28" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:29" class="footnote-text"><span>J.D. Valois, “Lock-Free Linked Lists Using Compare-and-Swap,” Proc. 14th Ann. ACM Symp. Principles of Distributed Computing, pp. 214-222, Aug. 1995.<a href="#fnref:29" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>concurrent</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>lock-free</tag>
      
      <tag>concurrent</tag>
      
      <tag>memory reclamation</tag>
      
      <tag>translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Relaxed Memory Concurrency</title>
    <link href="/2022/11/27/relaxed-memory-concurrency/"/>
    <url>/2022/11/27/relaxed-memory-concurrency/</url>
    
    <content type="html"><![CDATA[<p>内存一致性模型是是系统和程序员之间的规范，它规定了在一个共享存储器的多线程程序中的存储访问应该表现出怎样的行为。内存模型由以下两个属性组成：</p><ul><li><p>Memory Ordering</p><ul><li>Load-Load Order：不同地址上的读操作是否会乱序；</li><li>Load-Store Order：读操作和后面另一个地址上的写操作是否会乱序；</li><li>Store-Load Order：写操作和后面的读操作是否会乱序；</li><li>Store-Store Order：不同地址上的写操作是否会乱序；</li><li>Dependent Loads Order：当第二条读操作的地址取决于前一条读操作的结果时，是否会乱序。</li></ul></li><li><p>Store Atomicity（处理器的写操作是否会被所有处理器看到）</p><ul><li>Load Other’s Store Early &amp;&amp; Non-Causality：允许写操作被自己及个别其他处理器先看到，不支持 Causality。写序列可能以不同顺序被多个处理器观察到；</li><li>Load Other’s Store Early &amp;&amp; Causality：允许写操作被自己及个别其他处理器先看到，支持 Causality；</li><li>Load Own Store Early：只允许写操作被自己先看到。写序列以相同顺序被多个处理器观察到；</li><li>Atomic Store：所有处理器同时看到写操作。</li></ul></li></ul><p>最符合程序员直觉的是 SC（Sequential Consistency） Model，即所有的线程以交错的方式访问内存，并且在单个线程中访问内存的顺序与代码的执行顺序一致。这意味着，一个线程执行的操作对随后执行的线程可见，并且所有的线程都会看到一个相同的操作顺序。SC 的 Memory Model 属性：</p><ul><li>LL&#x2F;LS&#x2F;SL&#x2F;SS&#x2F;DL 乱序：不允许；</li><li>Store Atomicity：Load Own Store Early。</li></ul><p>在 SC Model 的基础上，逐步放松各个属性的限制，会依次得到各种弱一致性模型，可以统称为 Relaxed Memory Model。</p><blockquote><p>以上内容来自：<a href="https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md">https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md</a></p></blockquote><p>本文是 <a href="https://github.com/kaist-cp/cs431">CS431</a> 的学习笔记，记录了 Relaxed Memory Model 的 promising semantics 的原理和验证自旋锁实现正确性的例子。</p><h2 id="the-nondeterminism-due-to-shared-memory-accesses"><a href="#the-nondeterminism-due-to-shared-memory-accesses" class="headerlink" title="the nondeterminism due to shared memory accesses"></a>the nondeterminism due to shared memory accesses</h2><p>在基于共享内存实现的多线程并发程序中，执行结果常常具备大量的不确定性，不确定来源主要有两个：thread interleaving 和 instruction reordering。</p><h3 id="thread-interleaving"><a href="#thread-interleaving" class="headerlink" title="thread interleaving"></a>thread interleaving</h3><p>thread interleaving 指的是多线程的 Load&#x2F;Store 指令交替执行，导致执行结果的不确定性。例如下面这段程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>            X = a;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>            X = b;<br>        &#125;<br>    &#125;);<br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;X = &#123;&#125;&quot;</span>, X);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>handle1</code> 线程先执行，那么 <code>X = 1</code>；如果 <code>handle2</code> 线程先执行，那么 <code>X = 2</code>：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs r">PS C<span class="hljs-operator">:</span><span class="hljs-punctuation">\</span>Users<span class="hljs-punctuation">\</span><span class="hljs-number">25864</span><span class="hljs-punctuation">\</span>Desktop<span class="hljs-punctuation">\</span>relaxed_memory_concurrency<span class="hljs-operator">&gt;</span> cargo run<br>    Finished dev <span class="hljs-punctuation">[</span>unoptimized <span class="hljs-operator">+</span> debuginfo<span class="hljs-punctuation">]</span> target<span class="hljs-punctuation">(</span>s<span class="hljs-punctuation">)</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s<br>     Running `target\debug\relaxed_memory_concurrency.exe`<br>X <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>PS C<span class="hljs-operator">:</span><span class="hljs-punctuation">\</span>Users<span class="hljs-punctuation">\</span><span class="hljs-number">25864</span><span class="hljs-punctuation">\</span>Desktop<span class="hljs-punctuation">\</span>relaxed_memory_concurrency<span class="hljs-operator">&gt;</span> cargo run<br>    Finished dev <span class="hljs-punctuation">[</span>unoptimized <span class="hljs-operator">+</span> debuginfo<span class="hljs-punctuation">]</span> target<span class="hljs-punctuation">(</span>s<span class="hljs-punctuation">)</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s<br>     Running `target\debug\relaxed_memory_concurrency.exe`<br>X <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>thread interleaving 产生的不确定性非常容易推断，这也是我们所期望的，通过 thread interleaving 可以显著提高程序的性能。</p><h3 id="reordering"><a href="#reordering" class="headerlink" title="reordering"></a>reordering</h3><p>reordering 指的是 Load&#x2F;Store 指令被重排序，导致出现不符合直觉的执行结果。硬件和编译器会执行一些优化，只要不是访问相同的内存位置，任何 Load&#x2F;Store&#x2F;RMW 指令都可能会被重排序。例如下面这段程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;||<span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>() == <span class="hljs-number">1</span> &#123;<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>);||<span class="hljs-built_in">assert_eq!</span>(DATA, <span class="hljs-number">42</span>);<br>||      &#125;<br></code></pre></td></tr></table></figure><p>假设只存在 thread interleaving：</p><ul><li>线程2先执行 <code>if FLAG.load() == 1</code>，而此时 <code>FLAG = 0</code>，那么就不会执行 <code>assert_eq!(DATA, 42)</code>，程序运行正常；</li><li>线程1先执行 <code>DATA = 42; FLAG.store(1)</code>，然后线程后执行 <code>if FLAG.load() == 1</code>，此时 <code>FLAG = 1</code>，因此会进行 if 分支执行 <code>assert_eq!(DATA, 42)</code>，因为 <code>DATA = 42</code> 已经被执行了，因此断言不会失败，程序继续运行。</li></ul><p>可见，如果只存在 thread interleaving，那么上面的程序一定不会执行失败。但是，由于存在 reordering，<code>assert_eq!(DATA, 42)</code> 断言有可能会失败：</p><ul><li>Store hoisting：线程1中的 <code>FLAG.store(1)</code> 先执行，然后线程2执行 <code>if</code> 判断成功，之后执行 <code>assert_eq!(DATA, 42)</code> 断言就会失败，因为此时 <code>DATA = 0</code>；</li><li>Load hoisting：线程2中的 <code>assert_eq!(DATA, 42)</code> 先执行，此时 <code>DATA = 0</code>，因此断言失败，程序崩溃。</li></ul><p>我们把硬件&#x2F;编译器 reordering 导致的 unintended behaviors 统称为 relaxed behaviors，relaxed behaviors 无法在 thread interleaving 语义中观测到。</p><h3 id="solution-for-relaxed-behaviors-amp-orderings"><a href="#solution-for-relaxed-behaviors-amp-orderings" class="headerlink" title="solution for relaxed behaviors &amp; orderings"></a>solution for relaxed behaviors &amp; orderings</h3><p>可以使用 ordering primitives 禁止 reordering，从而避免出现 relaxed behaviors：</p><ul><li><p>Access ordering：使用 <code>Release/Acquire</code> synchronization。</p></li><li><p>Fence：在 Store&#x2F;Load 之间插入 <code>fence(SC)</code>；</p></li></ul><p>（1）使用  <code>Release/Acquire</code> synchronization：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;                ||   <span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(acquire) == <span class="hljs-number">1</span> &#123;<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, release);   ||       <span class="hljs-title function_ invoke__">assert</span>(DATA == <span class="hljs-number">42</span>);<br>                          ||   &#125;<br></code></pre></td></tr></table></figure><p>Release Store：禁止与 Store 之前的指令重排序；Acquire Load：禁止与 LOAD 之后的指令重排序。因此只要 <code>FLAG.load(acquire) == 1</code>，那么 <code>assert(DATA == 42)</code> 断言一定会成功。</p><p>（2）使用 <code>fence(SC)</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;                ||   <span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(relaxed) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-title function_ invoke__">fence</span>(SC);                ||       <span class="hljs-title function_ invoke__">fence</span>(SC);<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, relaxed);   ||       <span class="hljs-title function_ invoke__">assert</span>(DATA == <span class="hljs-number">42</span>);  &#125;<br></code></pre></td></tr></table></figure><p>SC fence：禁止重排序 SC fence 之前和之后的指令。那么，只要 <code>FLAG.load(acquire) == 1</code>，那么 <code>assert(DATA == 42)</code> 断言一定会成功。</p><p>但是 relaxed behaviors &amp; orderings 的精确含义是什么？到底什么行为是被允许的、什么行为是不被允许的？为了推断并发程序的正确性，我们需要为 relaxed behaviors &amp; orderings 找到一个好的语义。</p><h2 id="promising-semantics"><a href="#promising-semantics" class="headerlink" title="promising semantics"></a>promising semantics</h2><p><a href="https://sf.snu.ac.kr/promise-concurrency/">promising semantics</a> 是一种 Relaxed Memory Model，对 relaxed behaviors &amp; orderings 进行建模。它有下面的四个 Key idea：</p><ul><li>modeling load hoisting w&#x2F; <strong>multi-valued memory</strong>：Allowing a thread to read an old value from a location；</li><li>modeling read-modify-write w&#x2F; <strong>message adjacency</strong>：Forbidding multiple read-modify-writes of a single value；</li><li>modeling coherence &amp; ordering w&#x2F; <strong>views</strong>：Constraining a thread’s behavior；</li><li>modeling store hoisting w&#x2F; <strong>promises</strong>：Allowing a thread to speculatively write a value。</li></ul><h3 id="multi-valued-memory"><a href="#multi-valued-memory" class="headerlink" title="multi-valued memory"></a>multi-valued memory</h3><p>在 promising semantics 中内存是 location 到 list message 的映射，message 由 value 和 timestamp 组成。因此线程可以从一个 location 读取一个 old value。</p><p>multi-values memory 的目的是为 load hoisting 建模，例如 Load hoisting（r1&#x3D;r2&#x3D;0 allowed by reading old values from X and Y）：</p><img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-1.png" class=""><p>假设线程1先执行 <code>X = 1</code>，插入一条 <code>X = 1</code> 的 message：</p><img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-2.png" class=""><p>线程2执行 <code>Y = 1</code>，插入一条 <code>Y = 1</code> 的 message：</p><img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-3.png" class=""><p>线程1执行 <code>r1 = Y</code>，可以读到 <code>Y = 0</code> message，因此 <code>r1 = 0</code>：</p><img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-4.png" class=""><p>线程2执行 <code>r2 = X</code>，可以读到 <code>X = 0</code> message，因此 <code>r2 = 0</code>：</p><img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-5.png" class=""><p>综上所述，在 multi-value memory 中，从 <code>X</code> 和 <code>Y</code> 中可以读取 old value，<code>r1 = r2 = 0</code> 是可以出现的。</p><p>从 reordering 的角度考虑，线程1中的 <code>X = 1; r1 = Y</code> 可以被重排序，线程2中的 <code>Y = 1; r2 = X</code> 可以被重排序，因此 <code>r1 = r2 = 0</code> 可以出现，这也被称为 load hoisting。</p><p>在 x86 平台中，允许 Store-Load 重排序，因此可以用下面这段真实的程序验证 load hoisting：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> R1: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> R2: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> Y: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = <span class="hljs-number">2000000</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..total &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">test_load_hoisting</span>() &#123;<br>            count += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;load hoisting happens &#123;count&#125; times in &#123;total&#125; running.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_load_hoisting</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            X = <span class="hljs-number">1</span>;<br>            R1 = Y;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            Y = <span class="hljs-number">1</span>;<br>            R2 = X;<br>        &#125;<br>    &#125;);<br>    <br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = R1 == <span class="hljs-number">0</span> &amp;&amp; R2 == <span class="hljs-number">0</span>;<br>        R1 = <span class="hljs-number">0</span>;<br>        R2 = <span class="hljs-number">0</span>;<br>        X = <span class="hljs-number">0</span>;<br>        Y = <span class="hljs-number">0</span>;<br><br>        res<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行2000000次，发生了1次重排序：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">PS C:\Users\<span class="hljs-number">25864</span>\Desktop\relaxed_memory_concurrency&gt; cargo <span class="hljs-built_in">run</span> <span class="hljs-comment">--release</span><br>   <br>load hoisting happens <span class="hljs-number">1</span> <span class="hljs-keyword">times</span> <span class="hljs-keyword">in</span> <span class="hljs-number">2000000</span> <span class="hljs-built_in">running</span>.<br></code></pre></td></tr></table></figure><h3 id="message-adjacency"><a href="#message-adjacency" class="headerlink" title="message adjacency"></a>message adjacency</h3><p>为了对 read-modify-write 指令进行建模，需要对 message 增加限制，在 multi-value memory 中 message 的 timestamp 仅仅只一个点，而在 message adjacency 中 message 的 timestamp 具有范围。</p><p>message adjacency 对 RMW 指令进行建模，在执行 Read-Modify-writes 指令时，应该把一个新的 message 邻接到旧的 message 右边。例如 counter（r1&#x3D;r2&#x3D;0 forbidden）：</p><img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-1.png" class=""><p>线程1执行 <code>r1 = X.fetch_add(1)</code>，将 <code>X = 1</code> 的 message 邻接到 <code>X = 0</code> 的 message 的右边，此时 <code>r1 = 0</code>：</p><img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-2.png" class=""><p>线程2执行 <code>r2 = X.fetch_add(1)</code>，因为 <code>X = 0</code> 这条 message 已经被邻接了，因此 <code>X = 2</code> message 只能邻接到 <code>X = 1</code> message 的右边，因此只能读到 <code>X = 1</code> message，此时 <code>r2 = 1</code>：</p><img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-3.png" class=""><p>综上所述，<code>r1 = r2 = 0</code> 结果不可能出现，符合 RMW 指令的语义。</p><h3 id="views"><a href="#views" class="headerlink" title="views"></a>views</h3><p>multi-valued memory 允许太多的 unintended behaviors，当涉及到 coherence 和 synchronization 时需要增加限制。view 是 location 到 timestamp 的映射，表示 message 的确认。一共有三种 view：</p><ul><li><strong>Per-thread</strong> <strong>view</strong> for coherence；</li><li><strong>Per-message view</strong> for release&#x2F;acquire synchronization；</li><li><strong>A global view</strong> for SC synchronization。</li></ul><h4 id="Per-thread-view"><a href="#Per-thread-view" class="headerlink" title="Per-thread view"></a>Per-thread view</h4><p>Per-thread view 表示一个线程对 message 的确认，要求 reading&#x2F;writing 发生在当前线程的 view 之后，并且 reading&#x2F;writing 会改变当前线程的 view。</p><p>Per-thread view 用于建模 per-location coherence：</p><ul><li>RR coherence：X&#x3D;1 || r1&#x3D;X; r2&#x3D;X [r1&#x3D;1,r2&#x3D;0 impossible]</li><li>RW coherence:：r&#x3D;X; X&#x3D;1 [r&#x3D;0]</li><li>WR coherence:：X&#x3D;1; r&#x3D;X [r&#x3D;1]</li><li>WW coherence:：X&#x3D;1; X&#x3D;2 [X&#x3D;2 at the end]</li></ul><img src="/2022/11/27/relaxed-memory-concurrency/per-thread-view-1.png" class=""><p>以 WR coherence为例，执行代码 <code>X=1; r=X </code>：初始的线程 view 为 X &#x3D; 0 &amp; Y &#x3D; 0，当执行 <code>X = 1</code> 时，会插入一条 <code>X = 1</code> message，之后线程 view 变为 X &#x3D; 1 &amp; Y &#x3D; 0，此时再执行 <code>r = X</code>，由于 reading&#x2F;writing 只能发生在当前线程的 view 之后，因此一定会有 <code>r = 1</code>。这样就完成了对 WR coherence 的建模。</p><h4 id="Per-message-view"><a href="#Per-message-view" class="headerlink" title="Per-message view"></a>Per-message view</h4><p>Per-message view 表示执行 <code>AtomicType.store(T, release)</code> 产生的 released view，用于建模 release&#x2F;acquire synchronization。例如 message passing （X&#x3D;1 should be acknowledged after reading Y&#x3D;1）：</p><img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-1.png" class=""><p>线程1执行 <code>X = 1</code>，插入 <code>X=1</code> message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-2.png" class=""><p>线程1执行 <code>Y.store(1, release)</code>，插入 <code>Y=1</code> message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1，由于使用了 release，生成了一个 message view：X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-3.png" class=""><p>线程2执行 <code>Y.load(acquire)</code>，假设线程2读到 <code>Y=1</code> message，线程2的视图变为 X &#x3D; 0 &amp; Y &#x3D; 1，由于使用了 acquire，message view 会合并到线程2的 view 中，因此线程2的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-4.png" class=""><p>线程2执行 <code>assert(X == 1);</code>，此时线程2的 view 为 X &#x3D; 1 &amp; Y &#x3D; 1，因此会读取 X&#x3D;1 message，断言执行成功：</p><img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-5.png" class=""><p>可以看出，通过 Release&#x2F;Acquire 的使用，可以实现 message 在不同线程之间的传递。</p><h4 id="Global-view"><a href="#Global-view" class="headerlink" title="Global view"></a>Global view</h4><p>Global view 表示 SC fence 的当前累积 view，在一个 SC fence 之后，SC view 和 thread view 成为它们之中的最大者。Global view 用于建模 SC-fence synchronization，例如 message passing （X&#x3D;1 should be acknowledged after reading Y&#x3D;1）：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-1.png" class=""><p>线程1执行 <code>X = 1</code>，插入 X &#x3D; 1 message，线程1的 view 变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-2.png" class=""><p>线程1执行 <code>fence(SC)</code>，SC view 和 thread1 view 成为它们之间的最大者，因为此时 SC view 不存在，因此 thread1 view 保持不变，SC view 变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-3.png" class=""><p>线程1执行 <code>Y.store(1, relaxed)</code>，插入 Y &#x3D; 1 message，线程1的 view 变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-4.png" class=""><p>线程2执行 <code>Y.load(relaxed)</code>，假设线程2读到 Y &#x3D; 1 message，线程2的 view 变为 X &#x3D; 0 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-5.png" class=""><p>线程2执行 <code>fence(SC)</code>，SC view 和 thread2 view 成为它们之间的最大者，因此 thread2 view 变为 X &#x3D; 1 &amp; Y &#x3D; 1，SC view 变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/global-view-6.png" class=""><p>线程2执行 <code>assert(X == 1)</code>，此时线程2的 view 为 X &#x3D; 1 &amp; Y &#x3D; 1，因此线程2会读到 X &#x3D; 1 message，断言执行成功。</p><p>总结：通过 SC fence 的使用，也可以实现 message 在不同线程之间的传递。</p><h3 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h3><h4 id="Store-hoisting"><a href="#Store-hoisting" class="headerlink" title="Store hoisting"></a>Store hoisting</h4><p>与 load hoisting、RMW、coherence、synchronization 不同，store hoisting 更为复杂，涉及到以下三种情况：</p><p>（1）Store hoisting w&#x2F;o dependency（r1&#x3D;r2&#x3D;1 allowed by reordering in the right）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    X=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>线程2中 X 写入的值不依赖于其他指令，由于 Load-Store reordering，可以观察到 r1 &#x3D; r2 &#x3D; 1。</p><p>（2）Store hoisting w&#x2F; dependency（r1&#x3D;r2&#x3D;1 disallowed, “out of thin air” (OOTA)）</p><p>线程2中 X 写入的值依赖于上一条指令读取的值，此时不允许观察到 r1 &#x3D; r2 &#x3D; 1。如果 r1 &#x3D; r2 &#x3D; 1，则出现了 OOTA（out of thin air）behavior，那么我们将无法推断并发程序的正确性。</p><p>（3）Store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;1 allowed by compiler opt）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    <span class="hljs-keyword">if</span> r2==<span class="hljs-number">1</span>  &#123; X=r2 &#125;   <span class="hljs-comment">// “if” should be taken for the behavior,</span><br>              <span class="hljs-keyword">else</span>       &#123; X=<span class="hljs-number">1</span>  &#125;   <span class="hljs-comment">// but looks like OOTA</span><br></code></pre></td></tr></table></figure><p>从表面上来看，线程2中 X 写入的值依赖于上一条指令，但是<code>if r2 == 1 &#123; X = r2 &#125; else &#123; X = 1 &#125;</code> 无论执行哪个分治都有 <code>X = 1</code>，因此编译器可能会将其直接优化成：<code>X = 1</code>，这样就变成了情况（1）了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    X=<span class="hljs-number">1</span><span class="hljs-comment">// if r2 == 1 &#123; X = r2 &#125; else &#123; X = 1 &#125;</span><br></code></pre></td></tr></table></figure><p>优化之后的代码，线程2写入的值不依赖于其他指令，由于 Load-Store reordering，也可以观察到 r1 &#x3D; r2 &#x3D; 1。</p><p>这里的难点就是，我们需要找到一个好的 semantic model，其允许（1）和（3）但是不允许（2）。</p><h4 id="modeling"><a href="#modeling" class="headerlink" title="modeling"></a>modeling</h4><p>promises 对 store hoisting 建模：</p><ul><li><strong>Goal:</strong> allowing the hoisting of <strong>semantically independent writes</strong> only</li><li><strong>Idea:</strong> “semantically independent writes” are <strong>always writable</strong> in the future</li><li><strong>Mechanism</strong><ul><li>A thread may speculatively write a value (“promise to write”)</li><li>A thread should <strong>always be able to write its promises</strong> in the future</li></ul></li></ul><p>（1）例一：store hoisting w&#x2F;o dependency（r1&#x3D;r2&#x3D;1 allowed by reordering in the thread 2）</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-1.png" class=""><p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-2.png" class=""><p>为了验证线程2可以完成 promise write，需要屏蔽掉线程1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-5.png" class=""><p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 0</code> message，线程2视图保持不变。接着，线程2执行 <code>X = 1</code>，插入 X &#x3D; 1 message，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-6.png" class=""><p>promise write 得到验证，将线程2的视图还原，并将 X &#x3D; 1 message 标记为 Certified：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-7.png" class=""><p>线程1执行 <code>r1 = X</code>，假设读取 X &#x3D; 1 message，则线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-8.png" class=""><p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-9.png" class=""><p>线程2执行 <code>r2 = Y</code>，假设读取 Y &#x3D; 1 message，则线程2的视图更新为 X &#x3D; 0 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-10.png" class=""><p>线程2可以执行 <code>X = 1</code> 兑现 promise write，因此 promise 得到二次验证，将 X &#x3D; 1 message 标记为 Re-Certified：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-11.png" class=""><p>线程2执行 <code>X = 1</code>，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-1-12.png" class=""><p>（2）例二：store hoisting w&#x2F; dependency（r1&#x3D;r2&#x3D;1 disallowed, OOTA）</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-2-1.png" class=""><p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message。屏蔽线程1，线程2执行 <code>r2 = Y</code> 读取 Y &#x3D; 0 message，因此 r2 &#x3D; 0。线程2执行 <code>X = r2</code>，因为 r2 &#x3D; 0，线程2无法兑现 promise write，执行失败。</p><p>因此 r1 &#x3D; r2 &#x3D; 1 不可能成立。</p><p>（3）例三：store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;1 allowed）</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-1.png" class=""><p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-2.png" class=""><p>为了验证线程2可以兑现 promise write，需要屏蔽掉线程1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-5.png" class=""><p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 0</code> message，线程2视图保持不变。接着，线程2进入 else 分支，执行 <code>X = 1</code>，插入 X &#x3D; 1 message，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-6.png" class=""><p>promise write 得到验证，将线程2的视图还原，并将 X &#x3D; 1 message 标记为 Certified：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-7.png" class=""><p>线程1执行 <code>r1 = X</code>，假设读取 X &#x3D; 1 message，则线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-8.png" class=""><p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-9.png" class=""><p>线程2执行 <code>r2 = Y</code>，假设读取 Y &#x3D; 1 message，则线程2的视图更新为 X &#x3D; 0 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-10.png" class=""><p>因为 <code>r2 = 1</code>，线程2执行 <code>if r2 == 1</code> 进入 if 分支内部，接着可执行 <code>X = r2</code> 兑现 promise write，因此 promise 得到二次验证，将 X &#x3D; 1 message 标记为 Re-Certified：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-11.png" class=""><p>最后，线程2执行 <code>X = r2</code>，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-3-12.png" class=""><p>（4）例四：store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;r3&#x3D;1 disallowed due to RW coherence）</p><p>线程2 promise to write X &#x3D; 1，并验证 promise（验证过程与前面的例子一致，这里跳过）：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-4-1.png" class=""><p>线程1执行 <code>r1 = X</code>，假设读到 X &#x3D; 1 message，则线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-4-2.png" class=""><p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-4-3.png" class=""><p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 1</code> message，线程2的视图变为 X &#x3D; 0 &amp; Y &#x3D; 1。接着，线程2执行 <code>r3 = X</code>，假设读到 X &#x3D; 1 message，则线程2的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-4-4.png" class=""><p>由于 <code>r2 = 1</code>，因此进入 if 分支内部执行 <code>X = r2</code>，由于线程2的视图已经变为 X &#x3D; 1 &amp; Y &#x3D; 1，因此只能在当前视图的右边插入新的 X &#x3D; 1 message，那么就无法兑现 promise write，执行失败：</p><img src="/2022/11/27/relaxed-memory-concurrency/promises-4-5.png" class=""><p>因此 r1 &#x3D; r2 &#x3D; r3 &#x3D; 1 不可能成立。</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>Promising semantics is an operational semantics modeling relaxed behaviors and orderings.</p><p><strong>Key ideas</strong></p><ul><li><strong>Multi-valued memory:</strong> modeling load hoisting</li><li><strong>Message adjacency:</strong> modeling read-modify-write</li><li><strong>Views:</strong> modeling coherence and synchronization</li><li><strong>Promises:</strong> modeling store hoisting</li></ul><h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><h3 id="Spin-lock"><a href="#Spin-lock" class="headerlink" title="Spin lock"></a>Spin lock</h3><p>Spin lock 代码：<a href="https://github.com/kaist-cp/cs431/blob/main/src/lock/spinlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/spinlock.rs</a>。 关键方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">cas</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, acquire).<span class="hljs-title function_ invoke__">is_err</span>() &#123;&#125; <br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <br>    <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, release);            <br>&#125;<br></code></pre></td></tr></table></figure><p>Lock Guarantee：</p><ul><li>If a lock has already been acquired, lock() will spin.</li><li>Events between lock &amp; unlock are transferred via release&#x2F;acquire synch.</li><li>When holding the lock, you’ll access the latest value of D (no shared access).</li></ul><p>L 表示锁的状态，F 表示锁没有被占用，T 表示锁被占用了。D 表示锁保护的数据。绿色线条表示线程1 view，黑色线条表示线程2 view，黄色线条表示 message view。初始状态下，线程1的 view 和线程2的 view 相同：L &#x3D; F &amp; D &#x3D; Something1，message view 为上一个线程是否锁后产生的：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-1.png" class=""><p>线程1调用 <code>lock</code> 函数获取锁，执行 <code>cas(false, true, acquire)</code> 操作，读取 L &#x3D; F message，因此 cas 操作执行成功，邻接 L &#x3D; T message，由于使用了 acquire，message view 会合并到线程1的 view 中，线程1的 view 变为 L &#x3D; T &amp; D &#x3D; Something1：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-2.png" class=""><p>线程1持有锁，并修改 D，插入 D &#x3D; Something2 message，线程1的view 变为 L &#x3D; T &amp; D &#x3D; Something2：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-3.png" class=""><p>线程2调用 <code>lock</code> 函数获取锁，由于 L &#x3D; F message 已经被邻接了，只能读到 L &#x3D; T message，因此 cas 操作失败，进入 while 循环自旋，由于使用了 acquire，message view 会合并到线程2的 view 中，线程2的 view 变为 L &#x3D; T &amp; D &#x3D; Something1：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-4.png" class=""><p>线程1调用 <code>unlock</code> 函数释放锁，执行 <code>store(false, release)</code> 操作，插入 L &#x3D; F message，线程1的视图变为 L &#x3D; F &amp; D &#x3D; Something2，由于使用了 release，会生成 message view：L &#x3D; F &amp; D &#x3D; Something2：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-5.png" class=""><p>线程2调用 <code>lock</code> 函数获取锁，执行 <code>cas(false, true, acquire)</code> 操作，假设读到第二个 L &#x3D; F message，因此 cas 操作执行成功，邻接 L &#x3D; T message，由于使用了 acquire，message view 会合并到线程2的 view 中，线程2的 view 变为 L &#x3D; T &amp; D &#x3D; Something2：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-6.png" class=""><p>线程2持有锁，并修改 D，插入 D &#x3D; Something3 message，线程2的view 变为 L &#x3D; T &amp; D &#x3D; Something3：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-7.png" class=""><p>线程2调用 <code>unlock</code> 函数释放锁，执行 <code>store(false, release)</code> 操作，插入 L &#x3D; F message，线程2的视图变为 L &#x3D; F &amp; D &#x3D; Something3，由于使用了 release，会生成 message view：L &#x3D; F &amp; D &#x3D; Something3：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-8.png" class=""><p>最后，全图执行流程如下所示：</p><img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-9.png" class=""><p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，因此多个线程不会同时读写锁保护的数据，并且当一个线程持有锁时，另一个线程尝试获取锁则会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p><h3 id="Ticket-lock"><a href="#Ticket-lock" class="headerlink" title="Ticket lock"></a>Ticket lock</h3><p>Ticket lock 代码：<a href="https://github.com/kaist-cp/cs431/blob/main/src/lock/ticketlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/ticketlock.rs</a>。关键方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ticket</span> = <span class="hljs-keyword">self</span>.next.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.curr.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) != ticket &#123;&#125;<br><br>    ticket<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>, ticket: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">self</span>.curr.<span class="hljs-title function_ invoke__">store</span>(ticket.<span class="hljs-title function_ invoke__">wrapping_add</span>(<span class="hljs-number">1</span>), Ordering::Release);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/11/27/relaxed-memory-concurrency/ticket-lock.png" class=""><p>D 表示被锁保护的数据，绿色线条表示线程1，蓝色线条表示线程2。初始状态下，线程1的 view 为 next &#x3D; 0 &amp; cur &#x3D; 0 &amp; D &#x3D; D0，线程的 view 为 next &#x3D; 0 &amp; cur &#x3D; 0 &amp; D &#x3D; D0。执行流程描述如下：</p><ul><li>线程1执行 <code>self.next.fetch_add(1)</code>，读取 next &#x3D; 0 message，邻接 next &#x3D; 1 message，获取 ticket &#x3D; 0。接着执行 <code>self.curr.load</code>，读取 cur &#x3D; 0 message，因为 cur &#x3D; ticket &#x3D; 0，因此结束循环，返回 ticket，线程1的视图最终变为 next &#x3D; 1 &amp; cur &#x3D; 0 &amp; D &#x3D; D0；</li><li>线程2执行 <code>self.next.fetch_add(1)</code>，读取 next &#x3D; 1 message，邻接 next &#x3D; 2 message，获取 ticket &#x3D; 1。接着执行 <code>self.curr.load</code>，读取 cur &#x3D; 0 message，因为 cur !&#x3D; ticket，因此开始自旋，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 0 &amp; D &#x3D; D0；</li><li>线程1修改 D，插入 D &#x3D; D1 message，线程1的视图更新为 next &#x3D; 1 &amp; cur &#x3D; 0 &amp; D &#x3D; D1；</li><li>线程1释放锁，执行 <code>self.curr.store(ticket.wrapping_add(1), Release)</code> ，插入 cur &#x3D; 1 message，线程1的视图更新为 next &#x3D; 1 &amp; cur &#x3D; 1 &amp; D &#x3D; D1。因为使用了 Release，生成 message view：next &#x3D; 1 &amp; cur &#x3D; 1 &amp; D &#x3D; D1；</li><li>线程2执行 <code>self.curr.load(Ordering::Acquire)</code> ，假设读到 cur &#x3D; 1 message，此时 cur &#x3D; ticket &#x3D; 1，因此结束循环，返回 ticket，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D0。因为使用了 Acquire，把 message view 合并到线程2的view中，线程2的视图变为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D1；</li><li>线程2修改 D，插入 D &#x3D; D2 message，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D2；</li><li>线程2释放锁，执行 <code>self.curr.store(ticket.wrapping_add(1), Release)</code> ，插入 cur &#x3D; 2 message，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 2 &amp; D &#x3D; D2。因为使用了 Release，生成 message view：next &#x3D; 2 &amp; cur &#x3D; 2 &amp; D &#x3D; D2。</li></ul><p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，当一个线程持有锁时，另一个线程尝试获取锁会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p><h3 id="Clh-lock"><a href="#Clh-lock" class="headerlink" title="Clh lock"></a>Clh lock</h3><p>Clh lock 代码：<a href="https://github.com/kaist-cp/cs431/blob/main/src/lock/clhlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/clhlock.rs</a>。关键方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Token &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = Box::<span class="hljs-title function_ invoke__">into_raw</span>(Box::<span class="hljs-title function_ invoke__">new</span>(CachePadded::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">true</span>))));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">prev</span> = <span class="hljs-keyword">self</span>.tail.<span class="hljs-title function_ invoke__">swap</span>(node, Ordering::AcqRel);<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">unsafe</span> &#123; (*prev).locked.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#125; &#123;&#125;<br><br>    <span class="hljs-title function_ invoke__">drop</span>(<span class="hljs-keyword">unsafe</span> &#123; Box::<span class="hljs-title function_ invoke__">from_raw</span>(prev) &#125;);<br>    <span class="hljs-title function_ invoke__">Token</span>(node)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>, token: <span class="hljs-keyword">Self</span>::Token) &#123;<br>    (*token.<span class="hljs-number">0</span>).locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Ordering::Release);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/11/27/relaxed-memory-concurrency/clh-lock.png" class=""><p>D 表示被锁保护的数据，绿色线条表示线程1，蓝色线条表示线程2。初始状态下，线程1的 view 为 tail &#x3D; t0 &amp; node0 &#x3D; F &amp; D &#x3D; D0，线程2的 view 为 tail &#x3D; t0 &amp; node0 &#x3D; F &amp; D &#x3D; D0。执行流程描述如下：</p><ul><li>线程1调用lock函数，创建 node1，插入 node1 &#x3D; T message。线程1执行 <code>self.tail.swap(node1, AcqRel)</code>，读取 tail &#x3D; t0 message，邻接 tail &#x3D; t1 message，线程1的视图更新为 tail &#x3D; t1 &amp; node0 &#x3D; F &amp; node1 &#x3D; T &amp; D &#x3D; D0。由于使用了 AcqReq，生成 tail &#x3D; t1 的message view：tail &#x3D; t1 &amp; node0 &#x3D; F &amp; node1 &#x3D; T &amp; D &#x3D; D0。线程1执行 <code>(*node0).locked.load(Ordering::Acquire)</code>，读取 node0 &#x3D; F message，退出 while 循环。线程1执行 <code>drop(unsafe &#123; Box::from_raw(node0) &#125;)</code>，此时 node0 不会再有线程方法它，因此可以把 node0 相关的 message 从线程视图中删除，线程1 view 更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D0， tail &#x3D; t1 的message view    更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D0。线程1 返回 Token(node1)，此时线程1成功获取锁；</li><li>线程2调用lock函数，创建node2，插入 node2 &#x3D; T message。线程2执行 <code>self.tail.swap(node2, AcqRel)</code>，读取 tail &#x3D; t1 message，邻接 tail &#x3D; t2 message，由于使用使用了 AcqRel，因此将 tail &#x3D; t1 message view合并到线程2的视图中，线程2的视图更新为 tail &#x3D; t2 &amp; node1 &#x3D; T &amp; node2 &#x3D; T &amp; D &#x3D; D0，同时生成 tail &#x3D; t2 message view：tail &#x3D; t2 &amp; node1 &#x3D; T &amp; node2 &#x3D; T &amp; D &#x3D; D0。线程2执行 <code>(*node1).locked.load(Ordering::Acquire)</code>，读取 node1 &#x3D; T message，进入自旋；</li><li>线程1修改 D，插入 D &#x3D; D1 message，线程1的视图更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D1；</li><li>线程1释放锁，执行 <code>(*node1).locked.store(false, Release);</code> ，插入 node1 &#x3D; F message，线程1的视图更新为 tail &#x3D; t1 &amp; node1 &#x3D; F &amp; D &#x3D; D1。因为使用了 Release，生成 node1 &#x3D; F message view：tail &#x3D; t1 &amp; node1 &#x3D; F &amp; D &#x3D; D1；</li><li>线程2执行 <code>(*node1).locked.load(Ordering::Acquire)</code>，假设读到 node1 &#x3D; F message，则退出循环，由于使用了 Acquire，将 node1 &#x3D; F message view 合并线程2的 view中，线程2的视图更新为 tail &#x3D; t2 &amp; node1 &#x3D; F &amp; node2 &#x3D; T &amp; D &#x3D; D1。线程2执行 <code>drop(unsafe &#123; Box::from_raw(node1) &#125;)</code>，此时 node1 不会再有线程方法它，因此可以把 node1 相关的 message 从线程视图中删除，线程2 view 更新为 tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D1， tail &#x3D; t2 的message view    更新为 tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D1。线程2 返回 Token(node2)，此时线程2成功获取锁；</li><li>线程2修改 D，插入 D &#x3D; D2 message，线程2的视图更新为  tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D2；</li><li>线程2释放锁，执行 <code>(*node2).locked.store(false, Release);</code> ，插入 node2 &#x3D; F message，线程2的视图更新为 tail &#x3D; t2 &amp; node2 &#x3D; F &amp; D &#x3D; D2。因为使用了 Release，生成 node2 &#x3D; F message view：tail &#x3D; t2 &amp; node2 &#x3D; F &amp; D &#x3D; D2。</li></ul><p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，当一个线程持有锁时，另一个线程尝试获取锁会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p>]]></content>
    
    
    <categories>
      
      <category>concurrent</category>
      
    </categories>
    
    
    <tags>
      
      <tag>consistency</tag>
      
      <tag>rust</tag>
      
      <tag>note</tag>
      
      <tag>lock-free</tag>
      
      <tag>concurrent</tag>
      
      <tag>relaxed memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cacher and Blog</title>
    <link href="/2022/11/19/cacher-blog/"/>
    <url>/2022/11/19/cacher-blog/</url>
    
    <content type="html"><![CDATA[<p>最近闲着没事，又把 The Rust Book 看了一遍， 把第13章中的 <code>Cacher</code> 和第17章中的 <code>Blog</code> 例子完善了一下。</p><h2 id="Cacher"><a href="#Cacher" class="headerlink" title="Cacher"></a>Cacher</h2><p>在原版的基础上进行改进：</p><ul><li>使用 <code>HashMap</code> 存储 <code>arg</code> 到 <code>value</code> 的映射，对不同的 <code>arg</code> 参数缓存不同的值；</li><li>闭包中使用泛型参数，因此 <code>Cacher</code> 还可以缓存其他类型的值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> std::hash::Hash;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T, U&gt;<br><span class="hljs-keyword">where</span><br>    T: <span class="hljs-title function_ invoke__">Fn</span>(U) <span class="hljs-punctuation">-&gt;</span> U,<br>    U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Eq</span> + Hash,<br>&#123;<br>    calculation: T,<br>    value: HashMap&lt;U, U&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; Cacher&lt;T, U&gt;<br><span class="hljs-keyword">where</span><br>    T: <span class="hljs-title function_ invoke__">Fn</span>(U) <span class="hljs-punctuation">-&gt;</span> U,<br>    U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Eq</span> + Hash,<br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            calculation,<br>            value: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, arg: U) <span class="hljs-punctuation">-&gt;</span> U &#123;<br>        <span class="hljs-keyword">self</span>.value<br>            .<span class="hljs-title function_ invoke__">entry</span>(arg.<span class="hljs-title function_ invoke__">clone</span>())<br>            .<span class="hljs-title function_ invoke__">or_insert_with</span>(|| (<span class="hljs-keyword">self</span>.calculation)(arg))<br>            .<span class="hljs-title function_ invoke__">clone</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>在原版的基础上进行完善：</p><ul><li>增加 <code>reject</code> 方法将博文的状态从 <code>PendingReview</code> 变回 <code>Draft</code>；</li><li>在将状态变为 <code>Published</code> 之前需要两次 <code>approve</code> 调用；</li><li>只允许博文处于 <code>Draft</code> 状态时增加文本内容。</li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    state: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;&gt;,<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            state: <span class="hljs-title function_ invoke__">Some</span>(Box::<span class="hljs-title function_ invoke__">new</span>(Draft &#123;&#125;)),<br>            content: String::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">self</span>.content<br>            .<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">add_text</span>(text));<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">content</span>(<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>            <span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">request_review</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>            <span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">approve</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = <span class="hljs-keyword">self</span>.state.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>            <span class="hljs-keyword">self</span>.state = <span class="hljs-title function_ invoke__">Some</span>(s.<span class="hljs-title function_ invoke__">reject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, _post: &amp;<span class="hljs-symbol">&#x27;a</span> Post) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, _text: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Draft</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Draft</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        Box::<span class="hljs-title function_ invoke__">new</span>(PendingReview &#123;&#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        text<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PendingReview</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">PendingReview</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        Box::<span class="hljs-title function_ invoke__">new</span>(PrePublished &#123;&#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        Box::<span class="hljs-title function_ invoke__">new</span>(Draft &#123;&#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrePublished</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">PrePublished</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        Box::<span class="hljs-title function_ invoke__">new</span>(Published &#123;&#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Published</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Published</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, post: &amp;<span class="hljs-symbol">&#x27;a</span> Post) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        &amp;post.content<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> State&gt; &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态编码为类型"><a href="#状态编码为类型" class="headerlink" title="状态编码为类型"></a>状态编码为类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DraftPost</span> &#123;<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PendingReviewPost</span> &#123;<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrePublished</span> &#123;<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> DraftPost &#123;<br>        DraftPost &#123;<br>            content: String::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">content</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.content<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">DraftPost</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_text</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">self</span>.content.<span class="hljs-title function_ invoke__">push_str</span>(text);<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">request_review</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> PendingReviewPost &#123;<br>        PendingReviewPost &#123;<br>            content: <span class="hljs-keyword">self</span>.content,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PendingReviewPost</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> PrePublished &#123;<br>        PrePublished &#123;<br>            content: <span class="hljs-keyword">self</span>.content,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> DraftPost &#123;<br>        DraftPost &#123;<br>            content: <span class="hljs-keyword">self</span>.content,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PrePublished</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">approve</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Post &#123;<br>        Post &#123;<br>            content: <span class="hljs-keyword">self</span>.content,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Windows 上安装 Rust</title>
    <link href="/2022/09/17/rust-install-windows/"/>
    <url>/2022/09/17/rust-install-windows/</url>
    
    <content type="html"><![CDATA[<h2 id="Step1：安装-Windows-terminal"><a href="#Step1：安装-Windows-terminal" class="headerlink" title="Step1：安装 Windows terminal"></a>Step1：安装 Windows terminal</h2><p>打开 Windows 应用商店，搜索 terminal 并选择第一个搜索结果，然后点击下载即可：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE1.png" class=""><h2 id="Step2：安装-Chocolatey"><a href="#Step2：安装-Chocolatey" class="headerlink" title="Step2：安装 Chocolatey"></a>Step2：安装 Chocolatey</h2><p>以管理员的身份打开 Windows terminal，然后输入下面的命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Set</span>-ExecutionPolicy Bypass -Scope Process -Force; [<span class="hljs-keyword">System</span>.Net.ServicePointManager]::SecurityProtocol = [<span class="hljs-keyword">System</span>.Net.ServicePointManager]::SecurityProtocol -bor <span class="hljs-number">3072</span>; iex ((<span class="hljs-built_in">New</span>-<span class="hljs-keyword">Object</span> <span class="hljs-keyword">System</span>.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))<br></code></pre></td></tr></table></figure><p>安装完成后输入 <code>choco -v</code> 检查版本，如果输出了具体的版本号则表示安装成功。</p><h2 id="Step3：安装-mingw"><a href="#Step3：安装-mingw" class="headerlink" title="Step3：安装 mingw"></a>Step3：安装 mingw</h2><p>以管理员的身份打开 Windows terminal，然后输入下面的命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">choco <span class="hljs-keyword">install</span> mingw -y<br></code></pre></td></tr></table></figure><p>安装完成后输入 <code>gcc --version</code> 和 <code>g++ --version</code>，如果出现如下的输出则表示安装成功：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">PS C:\Users\<span class="hljs-number">25864</span>&gt; gcc --version<br>gcc.exe (MinGW-W64 x86_64-posix-<span class="hljs-keyword">seh, </span><span class="hljs-keyword">built </span><span class="hljs-keyword">by </span><span class="hljs-keyword">Brecht </span>Sanders) <span class="hljs-number">11</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br>Copyright (C) <span class="hljs-number">2021</span> Free Software Foundation, Inc.<br>This is free software<span class="hljs-comment">; see the source for copying conditions.  There is NO</span><br>warranty<span class="hljs-comment">; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><br>PS C:\Users\<span class="hljs-number">25864</span>&gt; g++ --version<br>g++.exe (MinGW-W64 x86_64-posix-<span class="hljs-keyword">seh, </span><span class="hljs-keyword">built </span><span class="hljs-keyword">by </span><span class="hljs-keyword">Brecht </span>Sanders) <span class="hljs-number">11</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><br>Copyright (C) <span class="hljs-number">2021</span> Free Software Foundation, Inc.<br>This is free software<span class="hljs-comment">; see the source for copying conditions.  There is NO</span><br>warranty<span class="hljs-comment">; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></code></pre></td></tr></table></figure><h2 id="Step4：安装-Rust"><a href="#Step4：安装-Rust" class="headerlink" title="Step4：安装 Rust"></a>Step4：安装 Rust</h2><p>打开 Rust 的官网：<a href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a> ，点击下载 RUSTUP-INIT.EXE（64位）：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE2.png" class=""><p>打开刚刚下载完的可执行文件：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE3.png" class=""><p>选择 3) Don’t install the prerequisites：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE4.png" class=""><p>选择 2) Customize installation：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE5.png" class=""><p>接下来会输入四个可选项：</p><img src="/2022/09/17/rust-install-windows/%E5%9B%BE6.png" class=""><p>然后输入 1 即可开始安装。</p><h2 id="Step5：验证是否安装成功"><a href="#Step5：验证是否安装成功" class="headerlink" title="Step5：验证是否安装成功"></a>Step5：验证是否安装成功</h2><p>打开 Windows terminal，输入 <code>rustc --version --verbose</code>，如果出现如下输出则表示安装成功：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">PS C:\Users\<span class="hljs-number">25864</span>&gt; rustc --version --verbose<br>rustc <span class="hljs-number">1.65</span>.<span class="hljs-number">0</span>-<span class="hljs-title function_ invoke__">nightly</span> (<span class="hljs-number">95</span>a992a68 <span class="hljs-number">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">16</span>)<br>binary: rustc<br>commit-hash: <span class="hljs-number">95</span>a992a68694d8bf3959bd2c0ac27ce9e9208b59<br>commit-date: <span class="hljs-number">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">16</span><br>host: x86_64-pc-windows-gnu<br>release: <span class="hljs-number">1.65</span>.<span class="hljs-number">0</span>-nightly<br>LLVM version: <span class="hljs-number">15.0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>最后通过安装一个 Rust 命令行工具来查看 Cargo 是否正常工作。在 Windows terminal 中输入 <code>cargo install onefetch</code>，如果出现如下输出则表示 Cargo 能够正常工作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"> ......<br> ......<br> Compiling ansi_term v0.<span class="hljs-number">12.1</span><br> Compiling owo-colors v3.<span class="hljs-number">5.0</span><br> Compiling zstd v0.<span class="hljs-number">11.2</span>+zstd.<span class="hljs-number">1.5</span>.<span class="hljs-number">2</span><br> Compiling askalono v0.<span class="hljs-number">4.6</span><br> Compiling git2 v0.<span class="hljs-number">14.4</span><br> Compiling onefetch v2.<span class="hljs-number">12.0</span><br>  Finished release [optimized] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>m <span class="hljs-number">59</span>s<br>Installing C:\Users\<span class="hljs-number">25864</span>\.cargo\bin\onefetch.exe<br> Installed package `onefetch v2.<span class="hljs-number">12.0</span>` (executable `onefetch.exe`)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://chocolatey.org/install#individual">https://chocolatey.org/install#individual</a></li><li><a href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sharded Key/Value Service</title>
    <link href="/2022/09/02/Sharded-Key-Value-Service/"/>
    <url>/2022/09/02/Sharded-Key-Value-Service/</url>
    
    <content type="html"><![CDATA[<p>6.824 的 LAB 4 的内容是构建一个分片的分布式 KV 存储系统。分片是 Key&#x2F;Value 对的子集。例如，所有以 “a” 开头的 Key 可能是一个分片，所有以 “b” 开头的 Key 可能是另一个分片。分片的目的是获取更好的性能，每个副本组只负责几个分片的 puts 和 gets，当访问的分片处于不同的副本组时，这些操作就可以并行地执行。因此，系统的总吞吐量与副本组的数量成正比。</p><p>分片 KV 存储系统包括两个主要组件：</p><ul><li>一组副本组。每个副本组负责分片的一个子集，并由少数使用 Raft 复制分片的服务器组成；</li><li>分片控制器。分片控制器决定一个副本组负责哪些分片，这个信息被称为配置。客户端询问分片控制器找到 Key 对应的副本组，副本组询问分片控制器找到要服务的分片。整个系统有一个单一的分片控制器，使用 Raft    作为容错服务实现。</li></ul><p>LAB 4 实验的主要挑战将是处理重新配置——将分片分配给副本组的更改。在一个副本组中，所有的服务器必须就何时应用新的配置达成一致。例如，Put 可能与重新配置同时到达，导致副本组不再负责对应的 Key。副本组中的服务器必须就 Put 发生在重新配置之前还是之后达成一致。如果之前，Put 应该生效，分片的新所有者应该看到它的效果；如果之后，Put 将不会生效，客户端必须在新所有者处重新尝试。</p><p>重新配置还需要副本组之间的交互。例如，在配置 10 中，副本组 G1 可能负责分片 S1。在配置 11 中，副本组 G2 可能负责分片 S1。在从 10 到 11 的重新配置过程中，G1 和 G2 必须使用 RPC 将分片 S1 从 G1 移动到 G2。</p><h2 id="LAB-4A"><a href="#LAB-4A" class="headerlink" title="LAB 4A"></a>LAB 4A</h2><p>LAB 4A 的内容是实现分片控制器，支持添加新的副本组、清除副本组以及在副本组之间移动分片。LAB 4A 的实现非常简单，除了没有使用快照之外，跟 LAB 3 的实现非常相似。</p><p>需要注意的是，当创建新的配置时，不要把之前的配置的 <code>Groups</code> 赋值给新的配置（因为 <code>Groups</code> 是引用类型），实现完后跑一下测试：</p><img src="/2022/09/02/Sharded-Key-Value-Service/%E5%9B%BE1.png" class=""><h2 id="LAB-4B"><a href="#LAB-4B" class="headerlink" title="LAB 4B"></a>LAB 4B</h2><p>LAB 4B 的内容是实现分片 KV 存储系统，为使用客户端接口的应用程序提供可线性化的接口。也就是说，对 Get、Put 和 Append 方法的完整应用程序调用必须以相同的顺序影响所有副本。 Get 应该看到最近的 Put&#x2F;Append 写入到同一个 Key 的值。即使 Gets 和 Puts 与配置更改几乎同时到达，也必须如此。</p><p>每个 shardkv 服务器都作为副本组的一部分运行。每个副本组为某些分片的 Key 提供 Get、Put 和 Append 操作。</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>我写完第一版代码后只通过了前面三个测试，第四个测试一直报错 Get 操作返回了错误的值。我反复检查了代码都没找到什么问题，于是就去仔细看了一下实验给的提示，终于发现了问题的所在。</p><p>提示里面给出了非常关键的信息：”Process re-configurations one at a time, in order.”，即应该按照顺序一次处理一个重新配置。在我之前的实现中副本组的 Leader 以100MS的频率向分片控制器询问最新配置，如果配置号大于当前的配置，那么就开始进行分片迁移，在分片迁移完成后进化到新的配置。但这样是有问题的，假设有如下的场景：</p><img src="/2022/09/02/Sharded-Key-Value-Service/%E5%9B%BE4.png" class=""><br><p>Server 1 和 Server 2 初始状态都是配置1，此时 Server 2 向分片控制器询问最新的配置，分片控制器返回了配置3。Server 2 根据配置3向 Server 1 发送分片2的请求，但是 Server 1 不拥有分片2，于是 Server 1会返回空数据或者无用的垃圾数据，Server 2 会把返回的垃圾数据保存起来，之后如果有客户端向 Server 2 发送 Get 请求，那么 Server 2 就会返回错误的值。</p><p>原因是副本组没有按照顺序处理重新配置，Server 2 不应该跳过配置2直接到达配置3，而是要先到达配置2，再到达配置3。</p><p>但即使这样还需要额外的判断才能保证正确性，假设副本组按照顺序一次处理一个重新配置，有如下的场景：</p><img src="/2022/09/02/Sharded-Key-Value-Service/%E5%9B%BE3.png" class=""><br><p>Server 1 初始状态是配置1，Server 2 初始状态是配置2。此时 Server 2 向分片控制器询问最新的配置，分片控制器返回了配置3。Server 2 根据配置3向 Server 1 发送分片2的请求，但是 Server 1 不拥有分片2，于是 Server 1会返回空数据或者无用的垃圾数据，Server 2 会把返回的垃圾数据保存起来，之后如果有客户端向 Server 2 发送 Get 请求，那么 Server 2 就会返回错误的值。</p><p>原因是 Server 2 的配置高于 Server 1，Server 1到达配置2后才会拥有分片2。因此当一个 Server 接收到请求分片的 RPC 时，需要先判断请求分片的配置号是否高于本服务器当前的配置，如果高于则返回一个错误提示告诉对方你要求的分片的配置太高了，否则就可以安全地把分片发送给对方。</p><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>再说一说在实现 LAB 4B 的过程中遇到的一个小 Bug。在我的之前的实现中，每当服务器返回一个分片给请求方时，都会直接把这个分片对应的 GID 设置为0，表示不再拥有这个分片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv *ShardKV)</span></span> doShard(command *Op) NotifyMsg &#123;<br><span class="hljs-comment">// ....</span><br>    <span class="hljs-comment">// ....</span><br><span class="hljs-keyword">for</span> _, shard := <span class="hljs-keyword">range</span> command.Shards &#123;<br><span class="hljs-comment">// ....</span><br>        <span class="hljs-comment">// ....</span><br>kv.config.Shards[shard] = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">return</span> notifyMsg<br>&#125;<br></code></pre></td></tr></table></figure><p>但这样做是有问题的，假设有如下的场景：</p><img src="/2022/09/02/Sharded-Key-Value-Service/%E5%9B%BE5.png" class=""><br><p>Server 1 已经到达了配置2，Server 2 到达了配置1。此时 Server 2 向分片控制器询问最新的配置，分片控制器返回了配置2，Server 2 根据配置2向 Server 1 发送分片1的请求，Server 1就把分片1的数据返回给 Server 2，并直接把 <code>kv.config.Shards[1]</code> 设置为0。</p><p>那么问题来了，当 Server 1 想要到达配置 3 时 需要分片1的数据，但是 Server 1已经把 <code>kv.config.Shards[1]</code> 置为0了，因此 Server 1 无法知道现在是谁拥有分片1。</p><p>解决方法很简单，加一个额外的判断即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> kv.config.Shards[shard] == kv.gid &#123;<br>kv.config.Shards[shard] = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 Server 1 已经到了配置2，则不把 <code>kv.config.Shards[shard]</code> 设置为0。</p><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><p>挑战1是垃圾状态收集，即当一个副本组失去对分片的所有权时，副本组应该把相应的分片数据删除。</p><p>最简单的办法是，在一个副本组返回分片给请求者后就立马把这个分片的数据删掉。但这样是有问题的，由于网络的不可靠性，请求者可能没有收到返回的分片数据，之后这个请求者就会重试，但此时副本组已经把这个分片删掉了，请求者不可能再拿到这个分片了。</p><p>解决方案是，副本组返回分片给请求者后不立即删掉这个分片。在请求者设置好分片后，再发送消息给分片的原来的持有者：告诉它这个分片我已经拿到了，你可以把这个分片的数据删掉了。这样副本组就能安全地删除掉分片了。</p><p>当然，这里面还有一些细节性的判断，这里就不再赘述了。</p><h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h3><p>挑战2是在配置更改期间能够处理客户端请求：</p><ul><li>在配置更改期间，如果一个分片没有收到影响，那么发送到这个分片的请求能够继续执行；</li><li>在配置更改期间，当副本组收到它需要的一个分片时，这个副本组可以立马为这个分片提供服务。</li></ul><p>第一个问题很简单，只要不在配置更改期间禁用客户端请求就可以通过这个测试。</p><p>对于第二个问题，解决方案是：在副本组得到一个分片后，就创建一个设置分片的操作提交到 Raft 中，当这个操作被复制到多数节点后，就执行这个操作，把分片保存到服务器状态中，之后就可以为这个分片提供服务了。这样就不需要等待到达新的配置就可以为新的分片提供服务了。</p><p>解决完所有的 Bug 并实现两个挑战后，跑一下测试：</p><img src="/2022/09/02/Sharded-Key-Value-Service/%E5%9B%BE2.png" class=""><h2 id="难度排序"><a href="#难度排序" class="headerlink" title="难度排序"></a>难度排序</h2><p>终于把 6.824 的所有 LAB 都做完了，结合我自己实现 LAB 的经历给这4个 LAB 的难度做一个排序吧：</p><ol><li>LAB 2。LAB 2 的难度最高，我认为主要是比较难 Debug，测试报错后很多时候都有上万行的日志，除了看日志以外没有什么好的 Debug 方法。我在做 LAB 2A 的时候参考了 Github 上的一个 Raft 的开源实现，主要是看一下需要定义哪些字段和方法，因为我刚开始做的时候完全不知道从哪儿下手😥。然后 2B、2C、2D 都是我完全独立完成的；</li><li>LAB 4。LAB 4 的难度比 LAB 2 的难度低一点，但是远高于 LAB 3 和 LAB 1 的难度。LAB 4A 和 4B 的所有内容都是我自己独立完成的，包括 4B 的最后两个挑战练习。LAB 4 的第一版代码我很快就写完了，但是只能通过前3个测试，直到看到 “Process re-configurations one at a time, in order.” 提示才直到自己哪儿错了，之后只改动几行代码就通过了前面的测试。再之后就慢慢地想要怎么实现最后的两个挑战练习，经过思考后也是顺利地完成了代码；</li><li>LAB 3。LAB 3 的难度本来挺低的，但是我在 LAB 3A 卡了接近一天，原因是我把 LAB 3 的架构搞错了（具体可见之前的文章），我看了一下别人的实现思路后才知道自己竟然犯了这么低级错误，之后改了10来行代码就通过所有测试了ヽ(✿ﾟ▽ﾟ)ノ；</li><li>LAB 1。LAB 1 的难度最低，我感觉 LAB 1 就相当于这门课的热身练习，实现逻辑比较简单，也没有什么复杂的交互，Debug 也比较简单。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>Fault-tolerant</tag>
      
      <tag>Key/Value Service</tag>
      
      <tag>Shard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fault-tolerant Key/Value Service（二）</title>
    <link href="/2022/08/22/Fault-tolerant-Key-Value-Service-2/"/>
    <url>/2022/08/22/Fault-tolerant-Key-Value-Service-2/</url>
    
    <content type="html"><![CDATA[<h2 id="具有快照功能的Key-x2F-Value-service"><a href="#具有快照功能的Key-x2F-Value-service" class="headerlink" title="具有快照功能的Key&#x2F;Value service"></a>具有快照功能的Key&#x2F;Value service</h2><p>LAB 3B在LAB 3A的基础上增加了快照的功能，随着Key&#x2F;Value服务的运行，其底层的Raft日志会越来越多，当超过某一阈值时，Key&#x2F;Value服务就需要创建一个快照，然后把快照传给Raft，Raft收到快照后就能够丢弃快照点之前的日志了。</p><p>Key&#x2F;Value服务也必须在崩溃重启后仍然能够过滤重复请求，这意味着LAB 3A中用来实现过滤重复请功能的数据结构也必须持久化到快照中。这样，当Key&#x2F;Value服务重启后，Key&#x2F;Value服务会首先读取持久化存储的快照，恢复在快照点的状态和客户端请求记录，之后再一条条执行快照点之后的日志，因此快照点之后的重复操作仍然可以被过滤。</p><h2 id="LAB-3B-中遇到的问题"><a href="#LAB-3B-中遇到的问题" class="headerlink" title="LAB 3B 中遇到的问题"></a>LAB 3B 中遇到的问题</h2><h3 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h3><p>第一个遇到的问题是 <code>TestSnapshotUnreliableRecoverConcurrentPartitionLinearizable3B</code> 测试没有通过，错误信息中显示客户端的写操作不是线性一致的。</p><p>截取的错误日志片段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ............</span><br><span class="hljs-number">188282</span> SNAP S4 receives snapshot: &amp;&#123;term: <span class="hljs-number">22</span> index: <span class="hljs-number">1576</span>&#125;<br><span class="hljs-number">188282</span> INFO S4 lastApplied: <span class="hljs-number">0</span>, kvTable: <span class="hljs-keyword">map</span>[], clientReqTable: <span class="hljs-keyword">map</span>[]<br><span class="hljs-number">188283</span> SNAP S4 applies a snapshot: &amp;&#123;term: <span class="hljs-number">22</span> index: <span class="hljs-number">1576</span>&#125;<br><span class="hljs-comment">// ............</span><br>nfo: wrote history visualization to /tmp/<span class="hljs-number">503826179.</span>html<br>--- FAIL: TestSnapshotUnreliableRecoverConcurrentPartitionLinearizable3B (<span class="hljs-number">29.60</span>s)<br>    test_test.<span class="hljs-keyword">go</span>:<span class="hljs-number">385</span>: history is not linearizable<br>FAIL<br>exit status <span class="hljs-number">1</span><br>FAIL<span class="hljs-number">6.824</span>/kvraft<span class="hljs-number">29.606</span>s<br></code></pre></td></tr></table></figure><p>日志中显示S4收到了Raft发来的一个空的快照，并且S4应用了这个快照，这导致S4的状态被清空，因此违反了线性一致性。</p><p>在我的Raft实现中，快照会被保存在Raft结构体中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Raft <span class="hljs-keyword">struct</span> &#123;<br>    snapshot[]<span class="hljs-type">byte</span> <span class="hljs-comment">//最近的快照</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当上层的Server传递快照给Raft时，Raft除了会把快照持久化存储起来之外，还会更新自己的 <code>snapshot</code> 字段的值。当 Leader 发送快照时会直接发送 <code>rf.snapshot</code> 的值而不会去读取持久化存储的快照。</p><p>但是在Raft初始启动时，我没有读取持久化存储的快照来初始化 <code>rf.snapshot</code>，而这就是问题的所在。当一个重新启动的节点被当选为 Leader 后，这个节点会向落后于它的快照点的其他节点发送快照，而此时快照是空的。当其他节点收到这个快照后，如果应用了这个快照，复制状态机的状态将会被清空，最终导致错误。</p><p>因此，需要在初始化Raft时读取持久化存储的快照来设置 <code>rf.snapshot</code> 的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Make</span><span class="hljs-params">(peers []*labrpc.ClientEnd, me <span class="hljs-type">int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">// ....</span></span><br><span class="hljs-params"><span class="hljs-function">rf.snapshot = rf.persister.ReadSnapshot()</span></span><br><span class="hljs-comment">// ....</span><br><br><span class="hljs-keyword">return</span> rf<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h3><p>第二个遇到的问题是 <code>TestSnapshotUnreliable3B</code> 测试没有通过。这个 Bug 是我在 LAB 3 中遇到的最难解决的一个Bug。</p><p>起初，我在测试时加了竞争检测器：<code>go test --run TestSnapshotUnreliable3B--race</code>，得到了如下的错误日志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ....</span><br>race: limit on <span class="hljs-number">8128</span> simultaneously alive goroutines is exceeded, dying<br>exit status <span class="hljs-number">66</span><br>FAIL<span class="hljs-number">6.824</span>/kvraft<span class="hljs-number">589.365</span>s<br></code></pre></td></tr></table></figure><p>错误日志中显示存在的Go程太多了，超过了8128个。我检查代码之后，没有找到哪里出了问题，所以就去搜了一下看别人有没有遇到这个问题，最终在知乎上看到了一篇文章有讲这个Bug。在那篇文章中作者提到是因为心跳太过频繁导致Go程开的太多，最终超过了竞争检测器的上限。</p><p>因此，我把心跳间隔设置为200MS（原来是100MS）再去测试，但是这个错误还是出现了，只是出现错误次数比之前少了很多。之后，我把竞争检测器去掉（<code>go test --run TestSnapshotUnreliable3B</code>），再并发跑500次测试，最终有一次测试发生了超时报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ....</span><br><span class="hljs-built_in">panic</span>: test timed out after <span class="hljs-number">10</span>m0s<br><br>goroutine <span class="hljs-number">79839</span> [running]:<br>testing.(*M).startAlarm.func1()<br>/usr/lib/<span class="hljs-keyword">go</span><span class="hljs-number">-1.13</span>/src/testing/testing.<span class="hljs-keyword">go</span>:<span class="hljs-number">1377</span> +<span class="hljs-number">0xdf</span><br>created by time.goFunc<br>/usr/lib/<span class="hljs-keyword">go</span><span class="hljs-number">-1.13</span>/src/time/sleep.<span class="hljs-keyword">go</span>:<span class="hljs-number">168</span> +<span class="hljs-number">0x44</span><br><span class="hljs-comment">// ....</span><br></code></pre></td></tr></table></figure><p>这个时候我才意识到有可能发生了死锁，当一个服务器发生死锁后，这个服务器就会被永久阻塞，在测试超时10分钟后就会发生panic。</p><p>没办法，只能硬着头皮去看这几万行的日志了&#x2F;(ㄒoㄒ)&#x2F;~~。经过一顿操作后，终于定位到了发生错误的日志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">100223</span> INFO S2 success changes lastApplied from <span class="hljs-number">237</span> to <span class="hljs-number">238</span><br><span class="hljs-number">100223</span> SNAP S2 generates snapshot: &amp;&#123;index: <span class="hljs-number">238</span>&#125;<br></code></pre></td></tr></table></figure><p>服务器S2在日志索引号238处想要生成一个快照，但是之后没有打印生成快照成功的日志。正常的生成快照得日志是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">102268</span> INFO S1 success changes lastApplied from <span class="hljs-number">247</span> to <span class="hljs-number">248</span><br><span class="hljs-number">102268</span> SNAP S1 generates snapshot: &amp;&#123;index: <span class="hljs-number">248</span>&#125;<br><span class="hljs-number">102270</span> INFO S1 generates snapshot success<br></code></pre></td></tr></table></figure><p>生成快照的函数实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv *KVServer)</span></span> genSnapshot() &#123;<br>w := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>e := labgob.NewEncoder(w)<br>    <br><span class="hljs-comment">// ....</span><br><br>data := w.Bytes()<br>kv.rf.Snapshot(kv.LastApplied, data)<br>&#125;<br></code></pre></td></tr></table></figure><p>生成快照完毕后会调用Raft的<code>Snapshot</code>函数并把快照作为参数传入。<code>Snapshot</code> 的函数实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> Snapshot(index <span class="hljs-type">int</span>, snapshot []<span class="hljs-type">byte</span>) &#123;<br><span class="hljs-comment">// Your code here (2D).</span><br>rf.mu.Lock()<br><span class="hljs-keyword">defer</span> rf.mu.Unlock()<br><br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-comment">//....</span><br><br>rf.persister.SaveStateAndSnapshot(state, snapshot)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Snapshot</code>函数中需要首先获取Raft的锁才能继续向下执行，所以我在<code>rf.mu.Lock()</code>后面加了一行日志以便于Debug：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br>log.Printf(<span class="hljs-string">&quot;S%d acquire lock successful&quot;</span>)<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>之后，再并发跑500次测试。检查出现的错误的测试日志，我发现某个服务器在最后一次生成快照的时候没有打印这条消息，这说明直到10分钟后测试超时这个服务器一直没有拿到锁，即这个服务器执行 <code>rf.mu.Lock()</code> 语句被阻塞住了。</p><p>我猜测这很可能是死锁造成的，经过一顿代码筛查，终于定位到了错误代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Raft 中安装快照RPC的handler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;<br><span class="hljs-comment">// ....</span><br>    rf.mu.Lock()<br>    <span class="hljs-keyword">defer</span> rf.mu.Unlock()<br><br>    msg := ApplyMsg&#123;&#125;<br>    rf.applyCh &lt;- msg<br>&#125;<br><br><span class="hljs-comment">// KvServer 中一个单独运行的Go程</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv *KVServer)</span></span> applyMsgToStateMachine() &#123;<br><span class="hljs-keyword">for</span> !kv.killed() &#123;<br>msg := &lt;-kv.applyCh<br>        <span class="hljs-comment">// ....</span><br><br><span class="hljs-keyword">if</span> msg.CommandValid &#123;<br><span class="hljs-comment">// ....</span><br>kv.genSnapshot()<br><span class="hljs-comment">// ....</span><br>&#125;<br>        <span class="hljs-comment">// ....</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设这样一个场景，S 收到了 Leader 发来的快照并执行 <code> rf.mu.Lock()</code>获取了 Raft 锁，之后 S 在会把快照发送给上层 Key&#x2F;Value服务：<code>rf.applyCh &lt;- msg</code>。</p><p>如果 Key&#x2F;Value 服务正在执行 <code>kv.genSnapshot</code>，那么 Key&#x2F;Value 服务也会尝试获取 Raft 锁，那么 <code>rf.applyCh</code> 就没有接收方。由于 <code>applyCh</code> 是同步管道，<code>InstallSnapshot</code> RPC会一直被阻塞住不会释放 Raft 锁，所以 <code>kv.genSnapshot</code> 也无法获取 Raft 锁，导致无法生成快照。</p><p>解决方法很简单，把发送快照给上层 Key&#x2F;Value服务的操作放在锁的外面即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;<br><span class="hljs-comment">// ....</span><br>    rf.mu.Lock()<br>    msg := ApplyMsg&#123;&#125;<br>    rf.mu.Unlock()<br>    <br>    rf.applyCh &lt;- msg<br>&#125;<br></code></pre></td></tr></table></figure><p>解决完所有的 Bug 后，并发跑500次测试全部通过：</p><img src="/2022/08/22/Fault-tolerant-Key-Value-Service-2/%E5%9B%BE1.png" class=""><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></li><li><a href="https://raft.github.io/raft.pdf">Raft paper</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>Fault-tolerant</tag>
      
      <tag>Key/Value Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fault-tolerant Key/Value Service（一）</title>
    <link href="/2022/08/19/Fault-tolerant-Key-Value-Service/"/>
    <url>/2022/08/19/Fault-tolerant-Key-Value-Service/</url>
    
    <content type="html"><![CDATA[<h2 id="LAB-3：分布式KV"><a href="#LAB-3：分布式KV" class="headerlink" title="LAB 3：分布式KV"></a>LAB 3：分布式KV</h2><p>6.824 LAB 3的内容是基于LAB 2实现的Raft库构建一个容错的Key&#x2F;Value服务。</p><p>容错的Key&#x2F;Value服务是一个复制状态机，由多个使用Raft进行复制的Key&#x2F;Value服务器组成。由于底层使用Raft实现复制，因此只要过半服务器没有故障并且能够互相通信，那么构建的Key&#x2F;Value服务就能够一直处理客户请求。整体架构如图所示：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE1.png" class=""><p>客户端可以向Key&#x2F;Value服务发送三种不同的RPC：</p><ul><li><p>Put(key, value)：替换数据库中某一特定Key对应的Value。</p></li><li><p>Append(key, arg)：将arg附加到Key对应的Value上。</p></li><li><p>Get(key)：获取Key对应的Value。对于一个不存在的Key，Get应该返回一个空字符串。</p></li></ul><p>每个客户端通过Clerk的Put&#x2F;Append&#x2F;Put方法与服务进行通信，Clerk负责管理与服务的RPC交互。</p><p>LAB 3要求客户端对Clerk的Get&#x2F;Put&#x2F;Append方法的调用是可线性化的。如果一次调用一个，Get&#x2F;Put&#x2F;Append方法应该表现得像系统只有一个副本一样，并且每次调用都应该观察到前面的调用序列对状态的修改（一个操作只能执行一次）。对于并发调用，返回值和最终状态必须与操作按某种顺序一次执行一个得到的结果相同。如果调用在时间上重叠，就是并发的：例如，如果客户端X调用Clerk.Put()，客户端Y调用Clerk.Append()，然后客户端X的调用返回。一个调用必须观察到在该调用开始之前已经完成的所有调用的效果。</p><h2 id="实现线性一致性"><a href="#实现线性一致性" class="headerlink" title="实现线性一致性"></a>实现线性一致性</h2><p>由于使用Raft实现复制，写操作已经实现了线性一致性，因为所有的服务器都会按照相同的顺序执行相同的写操作：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE2.png" class=""><p>对于读操作，我们可以把客户端的Get请求只发送到Leader，来确保一定能够读到最近写入的值。但是这样需要额外的机制来验证这个Leader是否是真的Leader，因为一个困在分区中的Leader是一个假Leader。</p><p>可以把读操作也提交到Raft日志中，这样所有的读写操作在所有的服务器中都会按照相同的顺序执行，并且读操作一定能够看到它之前的写操作写入的值。这种方法的缺点是性能差，为了把读操作的日志复制给大多数服务器，至少需要发送一轮AppendEntries RPC，需要花费10MS以上的时间。</p><h2 id="过滤重复请求"><a href="#过滤重复请求" class="headerlink" title="过滤重复请求"></a>过滤重复请求</h2><p>当一个客户端向Key&#x2F;Value服务器发送一个请求后，在超时时间内这个服务器可能执行不完这个请求，服务器会返回一个error给客户端，之后客户端会重新发送这个请求。因此，客户端可能会发送多条重复的请求给服务端。</p><p>这种情况下，服务器需要有能力过滤掉重复的请求，确保每个请求只执行一次。否则，服务器执行重复请求可能会导致状态的错误更改，导致违反线性一致性。</p><p>比如，客户端X向服务器发送请求 <code>Append(&quot;K&quot;, &quot;Hello&quot;)</code>，之后由于一些原因客户端X再次发送请求 <code>Append(&quot;K&quot;, &quot;Hello&quot;)</code>，如果服务器不过滤掉重复的请求，那么 <code>K</code> 对应的 Value 就会变为 <code>HelloHello</code>。但是在客户端看来，我只想要追加一个 <code>Hello</code>，最终却追加了两个，这显然不符合要求。</p><p>解决方法是在客户端存储一个客户端标识符和请求ID，并在服务端存储一张表，表中的每一项是客户端的标识符和对应的请求ID，请求ID是一个从1开始的递增整数。客户端每次发送请求时都把请求ID加一，然后把客户端标识符和请求ID附加到发送的请求中；服务器收到这个请求后可以查看这个客户端对应的最大请求ID，只有当发送过来的请求ID大于服务器存储的最大请求ID才执行这个请求，否者说明是一个重复的请求，直接返回即可。</p><h2 id="LAB-3A中遇到的问题"><a href="#LAB-3A中遇到的问题" class="headerlink" title="LAB 3A中遇到的问题"></a>LAB 3A中遇到的问题</h2><h3 id="架构理解错误"><a href="#架构理解错误" class="headerlink" title="架构理解错误"></a>架构理解错误</h3><p>在实现LAB 3A的是否遇到的第一个问题就是把架构理解错了。在我原先的理解中，系统中只存在一个Clerk，然后存在多个客户端，所有的客户端都调用同一个Clerk的Put&#x2F;Append&#x2F;Get方法，因此对Clerk的调用是并发的：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE3.png" class=""><p>但是，这样的话无法知道是谁调用的Put&#x2F;Append&#x2F;Get方法，因为这些方法中没有客户端ID这个参数。我原来的想法是Clerk每次发送请求之前先生成一个随机的请求ID，之后发送请求时附带上这个ID。这样服务端在执行完一条请求后就可以把这个请求ID和执行结果存储在一条表中，之后如果客户端发送了一条重复的请求，我们就可以根据请求ID直接把结果返回，而不需要再次执行。</p><p>这个方法的问题随着请求的执行，服务端存储的请求ID和执行结果会越来越多，而且没有什么有效的清理无用数据的方法。</p><p>想了半天没啥好的思路，我就看了一下别人的LAB 3的实现文档，才发现我把LAB 3的架构理解错了。正确的架构是，有多个客户端，并且每个客户端有自己的Clerk，每个客户端阻塞调用自己的Clerk的Put&#x2F;Append&#x2F;Get方法：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE4.png" class=""><p>这样，就能够使用上面提到的过滤重复请求的方法了。</p><h3 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h3><p>第一个遇到的问题是每条请求的执行时间过长，超过了33ms：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">--- FAIL: TestSpeed3A (<span class="hljs-number">101.08</span>s)<br>    test_test.<span class="hljs-keyword">go</span>:<span class="hljs-number">419</span>: Operations completed too slowly <span class="hljs-number">100.480114</span>ms/op &gt; <span class="hljs-number">33.333333</span>ms/op<br>FAIL<br>exit status <span class="hljs-number">1</span><br>FAIL    <span class="hljs-number">6.824</span>/kvraft    <span class="hljs-number">101.086</span>s<br></code></pre></td></tr></table></figure><p>我反复检查了LAB 3A的代码实现，都没找到啥问题，去网上搜了一下才发现是LAB2的实现策略有问题。</p><p>在我的LAB 2的实现中，心跳的间隔是100MS，并且只在心跳的是否才发送日志给其他的节点。如果只有一个客户端，客户端发送Put&#x2F;Append&#x2F;Get请求给服务器，服务器把这个请求提交给Raft，Raft需要等待100MS然后发送附加日志给其他的节点，之后才能提交执行这个请求，当服务器执行完这个请求后返回响应给客户端，之后客户端才能继续发起新的请求。因此，执行一条请求至少需要100MS，这没有达到33MS的要求。</p><p>解决方法很简单，在Raft执行Start方法添加完一条日志后，就立马发送心跳，这样就不需要等待100MS了。</p><h3 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h3><p>第二个Bug是与Go语言相关的。如果向<code>nil</code>管道发送值会发生死锁，发送端Go程会被永久阻塞。最开始我的实现是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">command.Ch &lt;- sendVal<br></code></pre></td></tr></table></figure><p>如果当前的服务器不是Leader，那么<code>command.Ch</code>就等于<code>nil</code>，因此在发送前需要加一个判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> command.Ch != <span class="hljs-literal">nil</span> &#123;<br>    command.Ch &lt;- sendVal<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bug-3"><a href="#Bug-3" class="headerlink" title="Bug 3"></a>Bug 3</h3><p>第三个Bug还是与Go语言相关的。对于一个同步管道，只有当接收方准备接收的时候，发送方才能发送过去，否则发送方会永久阻塞。最开始我的实现是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 某个函数</span><br><span class="hljs-keyword">if</span> command.Ch != <span class="hljs-literal">nil</span> &#123;<br>    command.Ch &lt;- sendVal<br>&#125;<br><br><br><span class="hljs-comment">// 某个函数</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> value := &lt;-waitCh:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, value<br><span class="hljs-keyword">case</span> &lt;-time.After(kv.waitTimeOut):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果在<code>kv.waitTimeOut</code>内还没有收到请求完成的通知，服务器会直接返回一个error给客户端。之后当请求完成后，执行<code>command.Ch &lt;- sendVal</code>就会发生永久阻塞，因为此时已经没有接收方了。</p><p>解决方法是，在发送端也设置一个超时，如果在超时时间内没有发送成功就直接退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> command.Ch != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> command.Ch &lt;- sendVal:<br>    <span class="hljs-keyword">case</span> &lt;-time.After(time.Microsecond):<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决完所有Bug后，并发跑500次测试：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE5.png" class=""><p>TestSpeed3A有一次测试没有通过，错误日志中显示每条操作花了37MS，没有达到33MS&#x2F;op的要求，但是这个问题应该已经在Bug 1中被解决了。测试报告中显示，TestSpeed3A平均花费了78.41秒才完成，但是在单独测试中只花了10.9秒就完成了：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE7.png" class=""><p>我就猜测可能是测试的时候开的线程太多导致的，毕竟我的电脑性能不太行。那么，只开5个线程并发跑500次TestSpeed3A测试：</p><img src="/2022/08/19/Fault-tolerant-Key-Value-Service/%E5%9B%BE6.png" class=""><p>所有的测试全部通过，并且平均只花费了13.13秒。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></li><li><a href="https://raft.github.io/raft.pdf">Raft paper</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>Fault-tolerant</tag>
      
      <tag>Key/Value Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft（五）：日志压缩和快照</title>
    <link href="/2022/08/08/Raft-5/"/>
    <url>/2022/08/08/Raft-5/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要快照？"><a href="#为什么需要快照？" class="headerlink" title="为什么需要快照？"></a>为什么需要快照？</h2><p>在 Raft 中，Log 压缩和快照解决的问题是：</p><ul><li><p>节约内存和磁盘的存储空间。对于一个长期运行的系统，例如运行了几周，几个月甚至几年，如果按照 Raft 论文图2的规则，那么 Log 会无限增长。最后可能会有数百万条 Log，从而需要大量的内存来存储。如果持久化存储在磁盘上，最终会消耗磁盘的大量空间。</p></li><li><p>减少崩溃重启后恢复应用程序状态花费的时间。如果一个服务器重启了，它需要重新从头开始执行这数百万条 Log 来重建自己的状态。当故障重启之后，遍历并执行整个 Log 的内容可能要花费几个小时来完成。这在某种程度上来说是浪费，因为在重启之前，服务器已经有了一定的应用程序状态。</p></li></ul><p>为了应对上面的问题，Raft 有了快照的概念。快照背后的思想是，将应用程序状态的拷贝单独存储下来。</p><p>对于大多数的应用程序来说，应用程序的状态远小于 Log 的大小。某种程度上，在某些时间点，Log 和应用程序的状态是可以互换的，它们是用来表示应用程序状态的不同事物。但是 Log 可能包含大量的重复的记录（例如KV存储中对同一个键的重复赋值），这些记录使用了 Log 中的大量的空间，但是可以压缩为表示应用程序状态的一条记录。这条记录通常比 Log 小的多，这就是快照的背后原理。</p><h2 id="快照实现策略"><a href="#快照实现策略" class="headerlink" title="快照实现策略"></a>快照实现策略</h2><p>当 Raft 认为它的 Log 太大，例如大于1MB，10MB或者任意的限制，Raft 会从 Log 中选取一个与快照对应的点，然后要求应用程序在那个点的位置做一个快照。之后，Raft 会持久化存储快照并丢弃快照点之前的日志条目。</p><p>当 Raft 服务器崩溃重启后，应用程序读取持久化存储的快照，恢复在快照点对应的状态。</p><p>但是，由于丢弃了快照之前 Log，这引入了大量的复杂性。如果有的 Follower 的 Log 很短，比 Leader 的快照点还短，那么 Leader 就不可能与 Follower 的日志匹配成功，因此 Leader 就无法通过 AppendEntries 的方式让 Follower 的 Log 补齐至 Leader 的 Log。</p><p>一种可能的解决方式是，如果 Leader 发现有任何一个 Follower 的 Log 落后于 Leader 快照的点，那么 Leader 就不丢弃快照之前的 Log。但是如果一个 Follower 关机了很长一段时间，那么 Leader 就不能确认这个 Follower 的 Log 条目，这就意味着 Leader 不能通过快照来减少自己的存储消耗。</p><p>Raft 选择的方法是，Leader 可以丢弃 Follower 需要的 Log。因此，我们需要某种机制能够处理 Follower Log 的结尾到 Leader Log 开始之间缺失的 Log，解决方法是 InstallSnapshot RPC。</p><p>当 Follower 收到 AppendEntries RPC 时，如果日志不匹配则会返回 false。Leader 收到 false 返回后，会回退自己的 Log，直到某个点为止 Leader 将不能再回退，此时它已经到了自己 Log 的起点。这时，Leader 会将自己的快照发给 Follower，之后通过 AppendEntries 将后面的 Log 发给 Follower。</p><p>具体的 InstallSnapshot 算法可以查看 <a href="https://raft.github.io/raft.pdf">Raft paper</a>（第七节）。</p><h2 id="LAB-2D"><a href="#LAB-2D" class="headerlink" title="LAB 2D"></a>LAB 2D</h2><p>LAB 2D 的实现不难，但是小细节挺多的。虽然实现的过程中遇到了很多Bug，但是都属于那种一眼就能知道问题在哪儿的类型，所以这里就不列举了。</p><p>最后，并发跑500次测试，全部顺利通过：</p><img src="/2022/08/08/Raft-5/Raft-%E5%9B%BE1.png" class=""><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></p></li><li><p><a href="https://raft.github.io/raft.pdf">Raft paper</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>consistency</tag>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft（四）：持久化存储</title>
    <link href="/2022/08/06/Raft-4/"/>
    <url>/2022/08/06/Raft-4/</url>
    
    <content type="html"><![CDATA[<h2 id="Raft-持久化"><a href="#Raft-持久化" class="headerlink" title="Raft 持久化"></a>Raft 持久化</h2><p>Raft 中所有服务器需要持久化存储的状态：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 candidateId，如果没有投给任何候选人则为空</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><p>当服务器改变了被标记为持久化的某个数据时，服务器应该将更新写入到磁盘或其他持久化存储中。这样当服务器故障重启后，就可以从持久化存储中找到相应的数据并将其加载到内存中，恢复之前的状态。</p><h3 id="currentTerm-持久化"><a href="#currentTerm-持久化" class="headerlink" title="currentTerm 持久化"></a>currentTerm 持久化</h3><p>currentTerm 需要被持久化存储是为了确保选举安全特性，即一个任期内最多只有一个 Leader 会被选举出来。</p><p>假设一共有三台服务器A、B、C。A是Leader，A有三条日志，其任期号分别为5、6、7；B有一条日志，任期号为5；C有一条日志，任期号为5。</p><p>这时，A还没复制日志给B、C，然后A、B、C都崩溃了。之后B、C重启，B、C需要选举出一个Leader，但是由于没有持久化 currentTerm，因此B、C不知道当前的任期号是多少，一种可能的方法是B、C通过查看自己的最后一条日志发现任期号为5，于是就会递增任期号并在任期6中选出一个Leader。</p><p>但是6是一个旧的任期号，在之前的这个任期中已经选举出了一个Leader了，这样一个任期中就选出了两个Leader，因此违反了选举安全特性。</p><h3 id="votedFor-持久化"><a href="#votedFor-持久化" class="headerlink" title="votedFor 持久化"></a>votedFor 持久化</h3><p>votefFor 需要被持久化存储也是为了确保选举安全特性。</p><p>假设一共有三台服务器A、B、C。A收到了B发来的投票请求，这时A检查发现自己的 votedFor 为空，于是给B投票。</p><p>然后A马上就崩溃重启了，这时收到C发来的投票请求，由于 votedFor 没有被持久化存储，因此B检查发现自己的 votedFor 为空，然后也会给C投票。这样B、C都收到了过半数的投票，B、C都会成为 Leader，这就违反了选举安全特性。</p><h3 id="log-持久化"><a href="#log-持久化" class="headerlink" title="log[] 持久化"></a>log[] 持久化</h3><p>日志需要被持久化存储是因为在崩溃重启后，应用程序可以根据保存的日志条目来重建崩溃前的运行状态。</p><p>假设由于断电或者其他原因导致所有的服务器全都重启了，这时所有的服务器都没有任何关于之前的日志条目信息，这样的话就不可能恢复到崩溃前的运行状态了。</p><h2 id="LAB-2C-中遇到的问题"><a href="#LAB-2C-中遇到的问题" class="headerlink" title="LAB 2C 中遇到的问题"></a>LAB 2C 中遇到的问题</h2><p>最后说一说，在实现 6.824 的 LAB 2C 的过程中遇到的两个 Bug。</p><h3 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h3><p>遇到的第一个Bug的错误日志如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go">                                    S1 starts election                                                                                                                      <br>                                    S1 becomes Candidate                                                                                                                    <br>                                    S1 change term from <span class="hljs-number">40</span> to <span class="hljs-number">41</span>                                                                                                            <br>                                    S1 votes <span class="hljs-keyword">for</span> S1                                                                                                                         <br>S0 receives VoteRequestRpc from S1                                                                                                                                          <br>S0 becomes Follower                                                                                                                                                         <br>S0 changes term from <span class="hljs-number">40</span> to <span class="hljs-number">41</span>                                                                                                                                               <br>S0 votes <span class="hljs-keyword">for</span> S1                                                                                                                                                             <br>                                                                      S2 receives VoteRequestRpc from                                                                       <br>                                                                      S1                                                                                                    <br>                                                                      S2 changes term from <span class="hljs-number">40</span> to <span class="hljs-number">41</span>                                                                         <br>                                                                                                                                          S4 sends hearbeat                 <br>                                                                                                                                          。。。。。。。。。<br><br>                                                                                                        S3 starts election                                                  <br>                                                                                                        S3 change term from <span class="hljs-number">40</span> to <span class="hljs-number">41</span>                                        <br>                                                                                                        S3 votes <span class="hljs-keyword">for</span> S3                                                     <br>                                                                                                                                          S4 sends hearbeat                 <br>                                                                                                                                           。。。。。。。。。<br><br>S0 starts election                                                                                                                                                          <br>S0 becomes Candidate                                                                                                                                                        <br>S0 change term from <span class="hljs-number">41</span> to <span class="hljs-number">42</span>                                                                                                                                                <br>S0 votes <span class="hljs-keyword">for</span> S0                                                                                                                                                             <br>                                    S1 receives VoteRequestRpc from                                                                                                         <br>                                    S0                                                                                                                                      <br>                                    S1 becomes Follower                                                                                                                     <br>                                    S1 changes term from <span class="hljs-number">41</span> to <span class="hljs-number">42</span>                                                                                                           <br>                                    S1 votes <span class="hljs-keyword">for</span> S0                                                                                                                         <br>                                                                      S2 receives VoteRequestRpc from                                                                       <br>                                                                      S0                                                                                                    <br>                                                                      S2 changes term from <span class="hljs-number">41</span> to <span class="hljs-number">42</span>                                                                         <br>                                                                                                                                          S4 sends hearbeat                 <br>                                                                                                                                           。。。。。。。。。<br><br>                                                                                                        S3 starts election                                                  <br>                                                                                                        S3 change term from <span class="hljs-number">41</span> to <span class="hljs-number">42</span>                                        <br>                                                                                                        S3 votes <span class="hljs-keyword">for</span> S3                                                     <br>                                                                                                                                          S4 sends hearbeat                 <br>                                                                                                                                           。。。。。。。。。<br><br>                                    S1 starts election                                                                                                                      <br>                                    S1 becomes Candidate                                                                                                                    <br>                                    S1 change term from <span class="hljs-number">42</span> to <span class="hljs-number">43</span>                                                                                                            <br>                                    S1 votes <span class="hljs-keyword">for</span> S1                                                                                                                         <br>S0 receives VoteRequestRpc from S1                                                                                                                                          <br>S0 becomes Follower                                                                                                                                                         <br>S0 changes term from <span class="hljs-number">42</span> to <span class="hljs-number">43</span>                                                                                                                                               <br>                                                                      S2 receives VoteRequestRpc from                                                                       <br>                                                                      S1                                                                                                    <br>                                                                      S2 changes term from <span class="hljs-number">42</span> to <span class="hljs-number">43</span>                                                                         <br>S0 votes <span class="hljs-keyword">for</span> S1  <br></code></pre></td></tr></table></figure><p>在这个场景中，S0、S1和S2在一个网络分区中，S3 和 S4 分别在一个网络分区中。S0、S1的日志没有S2的日志新。</p><p>从日志中可以看到，S1总是先发起选举，然后S2收到S1的投票请求后会转化为跟随者，S2会重置自己的选举计时器，这就导致S2一直无法发起选举投票。</p><p>解决方法是，在收到投票请求时，如果需要转化为跟随者，则不重置选举计时器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;<br>    rf.convertToFollower(args.Term, <span class="hljs-literal">false</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> convertToFollower(term <span class="hljs-type">int</span>, resetFlag <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-comment">// .......</span><br>    <span class="hljs-comment">// .......</span><br>    <span class="hljs-keyword">if</span> resetFlag &#123;<br>        rf.electionStart = time.Now()<br>        rf.electionTimeout = rf.randomElectionTimeout()<br>    &#125;<br>    <span class="hljs-keyword">go</span> rf.ticker()<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，即使S2在收到S1的投票请求后转化为跟随者，也不会重置选举超时计时器，在一定时间后S2将能够发起选举投票。</p><h3 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h3><p>遇到的第二个Bug的错误日志如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">018750</span> LEAD S2 sends hearbeat<br><span class="hljs-number">018750</span> INFO S2 sends hearbeat to S4: &amp;&#123;Term:<span class="hljs-number">4</span> LeaderId:<span class="hljs-number">2</span> PrevLogIndex:<span class="hljs-number">2</span> PrevLogTerm:<span class="hljs-number">3</span> Entries:[&#123;Command:<span class="hljs-number">2420</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">3</span>&#125; &#123;Command:<span class="hljs-number">6554</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">4</span>&#125; &#123;Command:<span class="hljs-number">6316</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">5</span>&#125; &#123;Command:<span class="hljs-number">648</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">6</span>&#125; &#123;Command:<span class="hljs-number">3226</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">7</span>&#125; &#123;Command:<span class="hljs-number">9916</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">8</span>&#125; &#123;Command:<span class="hljs-number">6121</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">9</span>&#125; &#123;Command:<span class="hljs-number">9155</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">10</span>&#125; &#123;Command:<span class="hljs-number">9102</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">11</span>&#125; &#123;Command:<span class="hljs-number">1911</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">12</span>&#125;] LeaderCommit:<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">018752</span> INFO S2 sends hearbeat to S0: &amp;&#123;Term:<span class="hljs-number">4</span> LeaderId:<span class="hljs-number">2</span> PrevLogIndex:<span class="hljs-number">2</span> PrevLogTerm:<span class="hljs-number">3</span> Entries:[&#123;Command:<span class="hljs-number">2420</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">3</span>&#125; &#123;Command:<span class="hljs-number">6554</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">4</span>&#125; &#123;Command:<span class="hljs-number">6316</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">5</span>&#125; &#123;Command:<span class="hljs-number">648</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">6</span>&#125; &#123;Command:<span class="hljs-number">3226</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">7</span>&#125; &#123;Command:<span class="hljs-number">9916</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">8</span>&#125; &#123;Command:<span class="hljs-number">6121</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">9</span>&#125; &#123;Command:<span class="hljs-number">9155</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">10</span>&#125; &#123;Command:<span class="hljs-number">9102</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">11</span>&#125; &#123;Command:<span class="hljs-number">1911</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">12</span>&#125;] LeaderCommit:<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">018753</span> INFO S2 sends hearbeat to S1: &amp;&#123;Term:<span class="hljs-number">4</span> LeaderId:<span class="hljs-number">2</span> PrevLogIndex:<span class="hljs-number">2</span> PrevLogTerm:<span class="hljs-number">3</span> Entries:[&#123;Command:<span class="hljs-number">2420</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">3</span>&#125; &#123;Command:<span class="hljs-number">6554</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">4</span>&#125; &#123;Command:<span class="hljs-number">6316</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">5</span>&#125; &#123;Command:<span class="hljs-number">648</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">6</span>&#125; &#123;Command:<span class="hljs-number">3226</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">7</span>&#125; &#123;Command:<span class="hljs-number">9916</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">8</span>&#125; &#123;Command:<span class="hljs-number">6121</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">9</span>&#125; &#123;Command:<span class="hljs-number">9155</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">10</span>&#125; &#123;Command:<span class="hljs-number">9102</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">11</span>&#125; &#123;Command:<span class="hljs-number">1911</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">12</span>&#125;] LeaderCommit:<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">018754</span> INFO S2 sends hearbeat to S3: &amp;&#123;Term:<span class="hljs-number">4</span> LeaderId:<span class="hljs-number">2</span> PrevLogIndex:<span class="hljs-number">2</span> PrevLogTerm:<span class="hljs-number">3</span> Entries:[&#123;Command:<span class="hljs-number">2420</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">3</span>&#125; &#123;Command:<span class="hljs-number">6554</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">4</span>&#125; &#123;Command:<span class="hljs-number">6316</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">5</span>&#125; &#123;Command:<span class="hljs-number">648</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">6</span>&#125; &#123;Command:<span class="hljs-number">3226</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">7</span>&#125; &#123;Command:<span class="hljs-number">9916</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">8</span>&#125; &#123;Command:<span class="hljs-number">6121</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">9</span>&#125; &#123;Command:<span class="hljs-number">9155</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">10</span>&#125; &#123;Command:<span class="hljs-number">9102</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">11</span>&#125; &#123;Command:<span class="hljs-number">1911</span> Term:<span class="hljs-number">4</span> CommandIndex:<span class="hljs-number">12</span>&#125;] LeaderCommit:<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">018764</span> VOTE S2 receives VoteRequestRpc from S3<br><span class="hljs-number">018764</span> INFO S2 becomes Follower<br><span class="hljs-number">018764</span> TERM S2 changes term from <span class="hljs-number">4</span> to <span class="hljs-number">5</span><br><span class="hljs-number">018866</span> VOTE S2 starts election<br><span class="hljs-number">018867</span> INFO S2 becomes Candidate<br><span class="hljs-number">018867</span> TERM S2 change term from <span class="hljs-number">5</span> to <span class="hljs-number">6</span><br><span class="hljs-number">018867</span> VOTE S2 votes <span class="hljs-keyword">for</span> S2<br><span class="hljs-number">018869</span> VOTE S1 receives VoteRequestRpc from S3<br><span class="hljs-number">018869</span> TERM S1 changes term from <span class="hljs-number">4</span> to <span class="hljs-number">5</span><br><span class="hljs-number">018870</span> VOTE S1 votes <span class="hljs-keyword">for</span> S3<br><span class="hljs-number">018988</span> INFO S3 receives AppendEntriesRpc from S2<br><span class="hljs-number">018988</span> INFO S3 reply AppendEntriesRpc from S2: &amp;Reply&#123;Term: <span class="hljs-number">5</span>, Success: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-number">018992</span> VOTE S3 receives VoteRequestRpc from S2<br><span class="hljs-number">018992</span> INFO S3 becomes Follower<br><span class="hljs-number">018992</span> TERM S3 changes term from <span class="hljs-number">5</span> to <span class="hljs-number">6</span><br><span class="hljs-number">018992</span> VOTE S3 votes <span class="hljs-keyword">for</span> S2<br><span class="hljs-number">019029</span> VOTE S1 receives VoteRequestRpc from S2<br><span class="hljs-number">019029</span> TERM S1 changes term from <span class="hljs-number">5</span> to <span class="hljs-number">6</span><br><span class="hljs-number">019029</span> VOTE S1 votes <span class="hljs-keyword">for</span> S2<br><span class="hljs-number">019032</span> INFO S2 becomes Leader<br><span class="hljs-number">019032</span> LEAD S2 sends hearbeat<br><span class="hljs-number">019033</span> INFO S2 sends hearbeat to S4: &amp;&#123;Term:<span class="hljs-number">6</span> LeaderId:<span class="hljs-number">2</span> PrevLogIndex:<span class="hljs-number">12</span> PrevLogTerm:<span class="hljs-number">4</span> Entries:[] LeaderCommit:<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">019035</span> INFO S1 receives AppendEntriesRpc from S2<br><span class="hljs-number">019035</span> INFO S1 reply AppendEntriesRpc from S2: &amp;Reply&#123;Term: <span class="hljs-number">6</span>, Success: <span class="hljs-literal">false</span>&#125;<br><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: index out of <span class="hljs-keyword">range</span> [<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>这是一个由于负数索引导致的运行崩溃错误，代码如下所示（在第20行崩溃）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br><span class="hljs-comment">// 已经不是领导人了，直接返回</span><br><span class="hljs-keyword">if</span> rf.role != LEADER &#123;<br>    rf.mu.Unlock()<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 跟随者节点已经被Kill了，直接返回</span><br><span class="hljs-keyword">if</span> reply.Term &lt; rf.currentTerm &#123;<br>    rf.mu.Unlock()<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123;<br>    rf.convertToFollower(reply.Term, <span class="hljs-literal">true</span>)<br>    rf.mu.Unlock()<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !reply.Success &#123;<br>    <span class="hljs-keyword">if</span> reply.XTerm == <span class="hljs-number">-1</span> &#123;<br>        rf.nextIndex[peerId] = prevLogIndex - reply.XLen + <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.XTerm == rf.log[reply.XIndex<span class="hljs-number">-1</span>].Term &#123;<br>        rf.nextIndex[peerId] = reply.XIndex + <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        rf.nextIndex[peerId] = reply.XIndex<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ....</span><br>    <span class="hljs-comment">// .....</span><br>&#125;<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>在我的实现中只有三种情况 <code>reply.Success = false</code>：</p><ul><li><p>节点已经被Kill了，这时候会返回 <code>reply.Term = 0</code></p></li><li><p>收到的心跳的任期号比当前节点的任期号小，这时候会返回 <code>reply.Term=XX</code></p></li><li><p>收到的心跳的<code>prevLogIndex</code>位置的日志不匹配，这时候会返回 <code>reply.XTerm=-1</code> 或 <code>reply.XIndex=YY</code></p></li></ul><p>第一种情况，第八行的代码会将其排除。第二种情况，第十二行代码会将其排除。第三种情况，如果要走到第20行，则只能是 <code>reply.XIndex=YY</code>，但是我的实现中 <code>YY</code> 一定大于0。这样，所有情况都排除了，那么为什么会出现这个问题呢？</p><p>通过观察日志可以发现，在第四行，S2给S1发送了一个心跳：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">S2 sends hearbeat to S1: &amp;&#123;Term:<span class="hljs-number">4</span>, ......&#125;<br></code></pre></td></tr></table></figure><p>此时S2的任期号为4。从第四行到第25行，S2先是变成了Follower，之后又在任期6被选举成为Leader。</p><p>在第28行，S1终于收到了S2发送的心跳，此时S1的保存的任期号为6，因此它会返回 <code>Reply&#123;Term: 6, Success: false, XIndex=0&#125;</code>。这是前面提到的第二种情况，但是此时S2的任期号也变成了6，因此第十二行代码就无法排除这种情况。最终代码就会执行到第20行，导致运行时崩溃。</p><p>可见，这是由于网络延迟导致的错误，解决方法也很简单，在第20行代码之前在加一个判断，如果<code>reply.XIndex=0</code>则不执行后面的代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reply.XTerm == <span class="hljs-number">-1</span> &#123;<br>    rf.nextIndex[peerId] = prevLogIndex - reply.XLen + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.XIndex != <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">if</span> reply.XTerm == rf.log[reply.XIndex<span class="hljs-number">-1</span>].Term &#123;<br>        rf.nextIndex[peerId] = reply.XIndex + <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        rf.nextIndex[peerId] = reply.XIndex<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决完上述的两个Bug后，并发跑500次测试，全部顺利通过：</p><img src="/2022/08/06/Raft-4/Raft-%E5%9B%BE1.png" class=""><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></p></li><li><p><a href="https://raft.github.io/raft.pdf">Raft paper</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>consistency</tag>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft（三）：日志复制</title>
    <link href="/2022/07/31/Raft-3/"/>
    <url>/2022/07/31/Raft-3/</url>
    
    <content type="html"><![CDATA[<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>具体的日志复制算法，在 Raft 论文中说的非常详细：<a href="https://raft.github.io/raft.pdf">Raft paper</a>（第5节、5.3节）。</p><p>在 LAB 2B 的实现中需要施加选举限制：<a href="https://raft.github.io/raft.pdf">Raft paper</a>（第5.4.1节）。</p><p>需要注意的是，Leader 只能提交当前任期内的日志：<a href="https://raft.github.io/raft.pdf">Raft paper</a>（第5.4.2节）。</p><h2 id="日志加速回退"><a href="#日志加速回退" class="headerlink" title="日志加速回退"></a>日志加速回退</h2><p>在 <a href="https://raft.github.io/raft.pdf">Raft paper</a>（第5节）中提到，如果 Leader 向一个 Follower 追加日志失败，就表明 Leader 和 Follower 的日志有冲突，则 Leader 会回退一个 Log，之后再次向跟随者追加日志。</p><p>假设有这样一个场景，我们有5个服务器，有1个 Leader，这个 Leader 和另一个 Follower 困在一个网络分区中。这个 Leader 一直向它唯一的 Follower 发送 AppendEntries，因为没有过半服务器，所以没有一条 Log 会 commit。在另一个有多数服务器的网络分区中，系统会选出新的 Leader 并继续运行。旧的 Leader 和它的 Follower 可能会记录无限多的旧的任期的未 commit 的 Log。当旧的 Leader 和它的 Follower 重新加入到集群中时，这些 Log 需要被删除并覆盖。</p><p>如果 Leader 每次只能在附加日志RPC 失败后回退一个 Log 然后重试的话，可能会耗费大量的时间。因此，需要某些方法来加速日志的回退。</p><p>6.824 的课堂上，Robert 教授给出了一个方法：让 Leader 可以每次回退一整个任期的 Log，而不是只回退一个 Log。</p><p>我们将可能的场景分成3类，在这里假设我们只有一个 Leader(S2)和一个 Follower(S1)，S2 要发送一条任期号为6的 AppendEntries 消息给 S1：</p><p>（1）场景一</p><p>S1没有任期6的 Log，因此我们需要回退一整个任期的 Log。</p><img src="/2022/07/31/Raft-3/Raft-%E5%9B%BE1.png" class=""><p>（2）场景二</p><p>S1 收到了任期4的旧 Leader 的多条 Log，但是作为新 Leader，S2 只收到了一条任期4的 Log。所以这里，我们需要覆盖 S1 中有关旧 Leader 的 Log。</p><img src="/2022/07/31/Raft-3/Raft-%E5%9B%BE2.png" class=""><p>（3）场景三</p><p>S1 与 S2 的 Log 不冲突，但是 S1 缺失了部分 S2 中的Log，这里我们回退掉所有空缺的 Log。</p><img src="/2022/07/31/Raft-3/Raft-%E5%9B%BE3.png" class=""><p>可以让 Follower 在回复 Leader 的 AppendEntries 消息中，携带3个额外的变量，来加速日志的恢复：</p><ul><li><p>XTerm：Follower 与 Leader 冲突的 Log 对应的任期号。如果 Follower 在 PrevLogIndex 位置的任期号与 Leader 不匹配，它会拒绝 Leader 的 AppendEntries 消息，并将自己的任期号放在 XTerm 中。如果 Follower 在对应位置没有 Log，那么这里会返回 -1。</p></li><li><p>XIndex：Folower 中任期号为 XTerm 的第一条 Log 的槽位号。</p></li><li><p>XLen：如果 Follower 在 PrevLogIndex 位置没有 Log，那么 XTerm 会返回-1，XLen 表示空白的 Log 槽位数。</p></li></ul><p>Leader 收到错误返回时，就可以根据上述信息加速日志回退：</p><ul><li><p>场景一：S1 会返回 XTerm&#x3D;5，XIndex&#x3D;2。S2 发现自己没有任期5的日志，它会将 S1 的 nextIndex 设置为 XIndex，也就是S1中，任期5的第一条Log对应的槽位号。</p></li><li><p>场景二：S1 会返回 XTerm&#x3D;4，XIndex&#x3D;1。S2 发现自己有任期4的日志，它会将 S1 的 nextIndex 设置为 XIndex+1。</p></li><li><p>场景三：S1 会返回 XTerm&#x3D;-1，XLen&#x3D;2。这表示 S1 中日志太短了，在冲突的位置没有 Log 条目，Leader 应该回退到 Follower 最后一条 Log 条目的下一条，也就是说 S2 会将 S1 的 nextIndex 设置为 nextIndex-XLen。</p></li></ul><h2 id="LAB-2B-中遇到的问题"><a href="#LAB-2B-中遇到的问题" class="headerlink" title="LAB 2B 中遇到的问题"></a>LAB 2B 中遇到的问题</h2><p>最后说一说，在实现 6.824 的 LAB 2B 的过程中遇到的一些 Bug。</p><h3 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h3><p>在运行 LAB 2B 的测试后，第一个没有通过的是测试 <code>TestRPCBytes2B</code>。错误日志如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 starts running                                                                                                                        <br>                                               S1 starts running                                                                         <br>                                                                                            S2 starts running                            <br>                                                                                            S2 starts election                           <br>                                                                                            S2 becomes Candidate                         <br>                                                                                            S2 change term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                   <br>                                                                                            S2 votes <span class="hljs-keyword">for</span> S2                              <br>S0 receives VoteRequestRpc from S2                                                                                                       <br>S0 becomes Follower                                                                                                                      <br>S0 changes term from <span class="hljs-number">1</span> to <span class="hljs-number">1</span>                                                                                                              <br>S0 votes <span class="hljs-keyword">for</span> S2                                                                                                                          <br>                                                                                            S2 becomes Leader                            <br>                                               S1 receives VoteRequestRpc from S2                                                        <br>                                               S1 becomes Follower                                                                       <br>                                               S1 changes term from <span class="hljs-number">1</span> to <span class="hljs-number">1</span>                                                               <br>                                               S1 votes <span class="hljs-keyword">for</span> S2                                                                           <br>                                                                                            S2 sends hearbeat                            <br>                                                                                            S2 becomes Leader                            <br>                                                                                            S2 sends hearbeat                                <br></code></pre></td></tr></table></figure><p>在错误日志中，S2 连续两次成为 Leader，导致 S2 中运行了两个 <code>heartbeat ticker</code>，因此 S2 就会发送比正常的 Leader 的两倍字节数，所以无法通过 <code>TestRPCBytes2B</code> 测试。</p><p>根据错误原因，可以定位错误是在请求投票的实现中，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startElection() &#123;<br>    <span class="hljs-comment">// 省略。。。。</span><br><br>    receivedVotes := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> rf.peers &#123;<br>        <span class="hljs-keyword">if</span> i == rf.me &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>            rf.mu.Lock()<br>            <span class="hljs-comment">// 已经不是候选者了，直接返回</span><br>            <span class="hljs-keyword">if</span> rf.role != CANDIDATE &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            args := &amp;RequestVoteArgs&#123;<br>                Term:         rf.currentTerm,<br>                CandidateId:  rf.me,<br>                LastLogIndex: rf.lastLogIndex,<br>                LastLogTerm:  rf.lastLogTerm,<br>            &#125;<br>            reply := &amp;RequestVoteReply&#123;&#125;<br>            rf.mu.Unlock()<br><br>            <span class="hljs-keyword">if</span> !rf.sendRequestVote(peerId, args, reply) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            rf.mu.Lock()<br>            <span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123;<br>                rf.convertToFollower(reply.Term)<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !reply.VoteGranted &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            receivedVotes++<br>            <span class="hljs-keyword">if</span> receivedVotes*<span class="hljs-number">2</span> &gt; <span class="hljs-built_in">len</span>(rf.peers) &#123;<br>                rf.convertToLeader()<br>            &#125;<br>            rf.mu.Unlock()<br>        &#125;(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 省略。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们把 Go 程中锁的使用分成两部分，第一部分：第10行（上锁）——第23行（解锁），第二部分：第29行（上锁）——第43行（解锁）。</p><p>假设所有的 Go 程都执行完第一部分后，再执行第二部分。这样所有的 Go 程都能发送请求投票RPC，因为此时当前的节点一定是跟随者。这样，当执行第二部分时，在得到的投票数达到半数服务器数量后，每多收到一票，就会调用 <code>rf.convertToLeader()</code> 转化为跟随者，从而导致上述的错误。</p><p>解决方法很简单，只需要在第二部分的开头增加一个对当前节点是否还是候选者的判断即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startElection() &#123;<br>    <span class="hljs-comment">// 省略。。。。</span><br><br>    receivedVotes := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> rf.peers &#123;<br>        <span class="hljs-keyword">if</span> i == rf.me &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>            rf.mu.Lock()<br>            <span class="hljs-comment">// 已经不是候选者了，直接返回</span><br>            <span class="hljs-keyword">if</span> rf.role != CANDIDATE &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            args := &amp;RequestVoteArgs&#123;<br>                Term:         rf.currentTerm,<br>                CandidateId:  rf.me,<br>                LastLogIndex: rf.lastLogIndex,<br>                LastLogTerm:  rf.lastLogTerm,<br>            &#125;<br>            reply := &amp;RequestVoteReply&#123;&#125;<br>            rf.mu.Unlock()<br><br>            <span class="hljs-keyword">if</span> !rf.sendRequestVote(peerId, args, reply) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            rf.mu.Lock()<br>            <span class="hljs-comment">// 已经不是候选者了，直接返回</span><br>            <span class="hljs-keyword">if</span> rf.role != CANDIDATE &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123;<br>                rf.convertToFollower(reply.Term)<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> !reply.VoteGranted &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            receivedVotes++<br>            <span class="hljs-keyword">if</span> receivedVotes*<span class="hljs-number">2</span> &gt; <span class="hljs-built_in">len</span>(rf.peers) &#123;<br>                rf.convertToLeader()<br>            &#125;<br>            rf.mu.Unlock()<br>        &#125;(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 省略。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h3><p>遇到的第二个 Bug 是由于使用负数索引导致的运行时崩溃，报错如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">Test (<span class="hljs-number">2</span>A): initial election ...<br>  ... Passed --   <span class="hljs-number">3.1</span>  <span class="hljs-number">3</span>   <span class="hljs-number">56</span>   <span class="hljs-number">16914</span>    <span class="hljs-number">0</span><br>Test (<span class="hljs-number">2</span>A): election after network failure ...<br><span class="hljs-number">2022</span>/<span class="hljs-number">07</span>/<span class="hljs-number">30</span> <span class="hljs-number">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">11</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: index out of <span class="hljs-keyword">range</span> [<span class="hljs-number">-1</span>]<br><br>goroutine <span class="hljs-number">230</span> [running]:<br><span class="hljs-number">6.824</span>/raft.(*Raft).sendHearbeat.func1(<span class="hljs-number">0xc0000c81e0</span>, <span class="hljs-number">0x1</span>)<br>    /mnt/d/code/projects/distributed-system/<span class="hljs-number">6.824</span>/src/raft/raft.<span class="hljs-keyword">go</span>:<span class="hljs-number">613</span> +<span class="hljs-number">0x66f</span><br>created by <span class="hljs-number">6.824</span>/raft.(*Raft).sendHearbeat<br>    /mnt/d/code/projects/distributed-system/<span class="hljs-number">6.824</span>/src/raft/raft.<span class="hljs-keyword">go</span>:<span class="hljs-number">571</span> +<span class="hljs-number">0x64</span><br>exit status <span class="hljs-number">2</span><br>FAIL    <span class="hljs-number">6.824</span>/raft    <span class="hljs-number">3.157</span>s<br></code></pre></td></tr></table></figure><p>索引越界具体发生在代码的613行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reply.XTerm == rf.log[reply.XIndex<span class="hljs-number">-1</span>].Term<br></code></pre></td></tr></table></figure><p>通过日志可以知道，发生错误时心跳 RPC 得到的返回消息是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">Reply &#123;<br>    Term: <span class="hljs-number">0</span><br>    Success: <span class="hljs-literal">false</span><br>    XTerm: <span class="hljs-number">0</span><br>    XIndex: <span class="hljs-number">0</span><br>    XLen: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据 Term&#x3D;0 和 Success&#x3D;false 可以看出跟随者似乎没有执行任何对心跳消息的处理就直接返回了。可以推断出，跟随者应该是已经”死掉“了，因此才没有执行对心跳消息的处理。</p><p>解决方法是，在发送心跳的函数中增加对跟随者节点状态的判断，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reply.Term &lt; rf.currentTerm &#123;<br>    rf.mu.Unlock()<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要 <code>reply.Term</code> 小于 Leader 的任期号，就可以知道跟随者没有对 Leader 发送的心跳进行处理，那么跟随者自然就已经”死掉了“。</p><h3 id="Bug-3"><a href="#Bug-3" class="headerlink" title="Bug 3"></a>Bug 3</h3><p>第三个遇到的问题是 <code>TestRejoin2B</code> 测试失败，失败的日志如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 sends hearbeat                                                                                                                                                           <br>S0 sends hearbeat to <span class="hljs-number">2</span>: &amp;&#123;Term:<span class="hljs-number">3</span>                                                                                                                                            <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">3</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">3</span> Entries:[]                                                                                                                                                    <br>LeaderCommit:<span class="hljs-number">3</span>&#125;                                                                                                                                                             <br>S0 sends hearbeat to <span class="hljs-number">1</span>: &amp;&#123;Term:<span class="hljs-number">3</span>                                                                                                                                            <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">2</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">2</span> Entries:[&#123;Command:<span class="hljs-number">104</span>                                                                                                                                         <br>Term:<span class="hljs-number">3</span> CommandIndex:<span class="hljs-number">3</span>&#125;]                                                                                                                                                     <br>LeaderCommit:<span class="hljs-number">3</span>&#125;                                                                                                                                                             <br>                                                                      S2 receives AppendEntriesRpc from                                                                     <br>                                                                      S0                                                                                                    <br>                                                                      S2 appends logs: []                                                                                   <br>                                                                      S2 changes commitIndex from <span class="hljs-number">2</span> to                                                                      <br>                                                                      <span class="hljs-number">3</span>                                                                                                     <br>                                                                      S2 reply AppendEntriesRpc from                                                                        <br>                                                                      S0: &amp;&#123;Term:<span class="hljs-number">3</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                     <br>                                                                      XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                                                      <br>                                                                      S2 applies msg&#123;Command:                                                                               <br>                                                                      %!s(<span class="hljs-type">int</span>=<span class="hljs-number">104</span>), Index: <span class="hljs-number">3</span>&#125;                                                                               <br>                                                                      S2 change lastApplied from <span class="hljs-number">2</span> to <span class="hljs-number">3</span>                                                                     <br>                                    S1 appends a log: &#123;Command:<span class="hljs-number">105</span>                                                                                                          <br>                                    Term:<span class="hljs-number">2</span> CommandIndex:<span class="hljs-number">3</span>&#125;                                                                                                                  <br>                                    S1 sends hearbeat                                                                                                                       <br>                                    S1 sends hearbeat to <span class="hljs-number">2</span>: &amp;&#123;Term:<span class="hljs-number">2</span>                                                                                                        <br>                                    LeaderId:<span class="hljs-number">1</span> PrevLogIndex:<span class="hljs-number">1</span>                                                                                                               <br>                                    PrevLogTerm:<span class="hljs-number">1</span>                                                                                                                           <br>                                    Entries:[&#123;Command:<span class="hljs-number">103</span> Term:<span class="hljs-number">2</span>                                                                                                            <br>                                    CommandIndex:<span class="hljs-number">2</span>&#125; &#123;Command:<span class="hljs-number">105</span>                                                                                                            <br>                                    Term:<span class="hljs-number">2</span> CommandIndex:<span class="hljs-number">3</span>&#125;]                                                                                                                 <br>                                    LeaderCommit:<span class="hljs-number">2</span>&#125;                                                                                                                         <br>                                                                      S2 receives AppendEntriesRpc from                                                                     <br>                                                                      S1                                                                                                    <br>                                                                      S2 reply AppendEntriesRpc from                                                                        <br>                                                                      S1: &amp;Reply&#123;Term: <span class="hljs-number">3</span>, Success:                                                                          <br>                                                                      <span class="hljs-literal">false</span>&#125;                                                                                                <br>                                    S1 becomes Follower                                                                                                                     <br>                                    S1 changes term from <span class="hljs-number">3</span> to <span class="hljs-number">3</span>                                                                                                             <br>                                    S1 sends hearbeat to <span class="hljs-number">0</span>: &amp;&#123;Term:<span class="hljs-number">3</span>                                                                                                        <br>                                    LeaderId:<span class="hljs-number">1</span> PrevLogIndex:<span class="hljs-number">2</span>                                                                                                               <br>                                    PrevLogTerm:<span class="hljs-number">2</span>                                                                                                                           <br>                                    Entries:[&#123;Command:<span class="hljs-number">105</span> Term:<span class="hljs-number">2</span>                                                                                                            <br>                                    CommandIndex:<span class="hljs-number">3</span>&#125;] LeaderCommit:<span class="hljs-number">2</span>&#125;                                                                                                        <br>S0 receives AppendEntriesRpc from                                                                                                                                           <br>S1                                                                                                                                                                          <br>S0 becomes Follower                                                                                                                                                         <br>S0 appends logs: [&#123;Command:<span class="hljs-number">105</span>                                                                                                                                              <br>Term:<span class="hljs-number">2</span> CommandIndex:<span class="hljs-number">3</span>&#125;]                                                                                                                                                     <br>S0 reply AppendEntriesRpc from S1:                                                                                                                                          <br>&amp;&#123;Term:<span class="hljs-number">3</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                                                                                               <br>XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                  <br></code></pre></td></tr></table></figure><p>在上面的日志中，S0 是 Leader 并且和 S2 可以正常通信，S1 被困在一个单独的网络分区中，并且自认为自己是 Leader。</p><p>当 S1 恢复正常后，S1 向 S2 发送 AppendEntries，然后收到了拒绝回复，并根据回复中的任期号重置自己的任期号，将自己转化为跟随者。到这里一切都还正常，但是接着 S1 继续向 S0 发送了 AppendEntries，导致 S0 退化成了跟随者，并且被追加了一条来自跟随者的日志，从而导致错误。</p><p>错误原因很明显，S1 在发送 AppendEntries 之前没有判断自己是否还是 Leader，因此在 S1 转变为跟随者之后，S1 仍然向 S0 发送了RPC消息。</p><p>那么，只需要在发送 AppendEntries 之前加一个小的条件判断即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 已经不是领导人了，直接返回</span><br><span class="hljs-keyword">if</span> rf.role != LEADER &#123;<br>    rf.mu.Unlock()<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bug-4"><a href="#Bug-4" class="headerlink" title="Bug 4"></a>Bug 4</h3><p>最后遇到的 Bug 是没有通过 <code>TestFailNoAgree2B</code> 测试，错误日志如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 starts running                                                                                                                                                           <br>                                    S1 starts running                                                                                                                       <br>                                                                      S2 starts running                                                                                     <br>                                                                                                        S3 starts running                                                   <br>                                                                                                                                          S4 starts running                 <br>S0 starts election                                                                                                                                                          <br>S0 becomes Candidate                                                                                                                                                        <br>S0 change term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                                                                                                  <br>S0 votes <span class="hljs-keyword">for</span> S0                                                                                                                                                             <br>                                    S1 receives VoteRequestRpc from                                                                                                         <br>                                    S0                                                                                                                                      <br>                                    S1 changes term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                                                             <br>                                    S1 votes <span class="hljs-keyword">for</span> S0                                                                                                                         <br>                                                                      S2 receives VoteRequestRpc from                                                                       <br>                                                                      S0                                                                                                    <br>                                                                      S2 changes term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                           <br>                                                                      S2 votes <span class="hljs-keyword">for</span> S0                                                                                       <br>S0 becomes Leader                                                                                                                                                           <br>S0 sends hearbeat                                                                                                                                                           <br>S0 sends hearbeat to S4: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[]                                                                                                                                                    <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                                                                                                                          S4 receives AppendEntriesRpc from <br>                                                                                                                                          S0                                <br>                                                                                                                                          S4 changes term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>       <br>                                                                                                                                          S4 appends logs: []               <br>                                                                                                                                          S4 reply AppendEntriesRpc from S0:<br>                                                                                                                                          &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>     <br>                                                                                                                                          XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                  <br>S0 sends hearbeat to S1: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[]                                                                                                                                                    <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                    S1 receives AppendEntriesRpc from                                                                                                       <br>                                    S0                                                                                                                                      <br>                                    S1 appends logs: []                                                                                                                     <br>                                    S1 reply AppendEntriesRpc from                                                                                                          <br>                                    S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                                                       <br>                                    XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                                                                                        <br>S0 sends hearbeat to S3: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[]                                                                                                                                                    <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                                                                                        S3 starts election                                                  <br>                                                                                                        S3 becomes Candidate                                                <br>                                                                                                        S3 change term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                          <br>                                                                                                        S3 votes <span class="hljs-keyword">for</span> S3                                                     <br>S0 appends a log: &#123;Command:<span class="hljs-number">10</span>                                                                                                                                               <br>Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;                                                                                                                                                      <br>S0 sends hearbeat                                                                                                                                                           <br>S0 sends hearbeat to S4: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[&#123;Command:<span class="hljs-number">10</span>                                                                                                                                          <br>Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                                                     <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                                                                                                                          S4 receives AppendEntriesRpc from <br>                                                                                                                                          S0                                <br>                                                                                                                                          S4 appends logs: [&#123;Command:<span class="hljs-number">10</span>     <br>                                                                                                                                          Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]           <br>                                                                                                                                          S4 reply AppendEntriesRpc from S0:<br>                                                                                                                                          &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>     <br>                                                                                                                                          XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                  <br>S0 sends hearbeat to S2: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[]                                                                                                                                                    <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                                                      S2 receives AppendEntriesRpc from                                                                     <br>                                                                      S0                                                                                                    <br>                                                                      S2 appends logs: []                                                                                   <br>                                                                      S2 reply AppendEntriesRpc from                                                                        <br>                                                                      S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                     <br>                                                                      XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                                                      <br>S0 receives VoteRequestRpc from S3                                                                                                                                          <br>                                    S1 receives VoteRequestRpc from                                                                                                         <br>                                    S3                                                                                                                                      <br>                                                                      S2 receives VoteRequestRpc from                                                                       <br>                                                                      S3                                                                                                    <br>                                                                                                                                          S4 receives VoteRequestRpc from S3<br>S0 sends hearbeat to S1: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[&#123;Command:<span class="hljs-number">10</span>                                                                                                                                          <br>Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                                                     <br>LeaderCommit:<span class="hljs-number">0</span>&#125;                                                                                                                                                             <br>                                    S1 receives AppendEntriesRpc from                                                                                                       <br>                                    S0                                                                                                                                      <br>                                    S1 appends logs: [&#123;Command:<span class="hljs-number">10</span>                                                                                                           <br>                                    Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                 <br>                                    S1 reply AppendEntriesRpc from                                                                                                          <br>                                    S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                                                       <br>                                    XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                                                                                        <br>S0 changes commitIndex from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                                                                                          <br>S0 sends hearbeat to S2: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[&#123;Command:<span class="hljs-number">10</span>                                                                                                                                          <br>Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                                                     <br>LeaderCommit:<span class="hljs-number">1</span>&#125;                                                                                                                                                             <br>                                                                      S2 receives AppendEntriesRpc from                                                                     <br>                                                                      S0                                                                                                    <br>                                                                      S2 appends logs: [&#123;Command:<span class="hljs-number">10</span>                                                                         <br>                                                                      Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                               <br>                                                                      S2 changes commitIndex from <span class="hljs-number">0</span> to                                                                      <br>                                                                      <span class="hljs-number">1</span>                                                                                                     <br>                                                                      S2 reply AppendEntriesRpc from                                                                        <br>                                                                      S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                                                     <br>                                                                      XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                                                      <br>S0 sends hearbeat to S3: &amp;&#123;Term:<span class="hljs-number">1</span>                                                                                                                                           <br>LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[&#123;Command:<span class="hljs-number">10</span>                                                                                                                                          <br>Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                                                     <br>LeaderCommit:<span class="hljs-number">1</span>&#125;                                                                                                                                                             <br>                                                                                                        S3 receives AppendEntriesRpc from                                   <br>                                                                                                        S0                                                                  <br>                                                                                                        S3 becomes Follower                                                 <br>                                                                                                        S3 appends logs: [&#123;Command:<span class="hljs-number">10</span>                                       <br>                                                                                                        Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                             <br>                                                                                                        S3 changes commitIndex from <span class="hljs-number">0</span> to                                    <br>                                                                                                        <span class="hljs-number">1</span>                                                                   <br>                                                                                                        S3 reply AppendEntriesRpc from                                      <br>                                                                                                        S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                   <br>                                                                                                        XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                    <br>                                                                                                        S3 receives AppendEntriesRpc from                                   <br>                                                                                                        S0                                                                  <br>                                                                                                        S3 appends logs: []                                                 <br>                                                                                                        S3 reply AppendEntriesRpc from                                      <br>                                                                                                        S0: &amp;&#123;Term:<span class="hljs-number">1</span> Success:<span class="hljs-literal">true</span> XTerm:<span class="hljs-number">0</span>                                   <br>                                                                                                        XIndex:<span class="hljs-number">0</span> XLen:<span class="hljs-number">0</span>&#125;                                                    <br>                                                                      S2 applies msg&#123;Command:                                                                               <br>                                                                      %!s(<span class="hljs-type">int</span>=<span class="hljs-number">10</span>), Index: <span class="hljs-number">1</span>&#125;                                                                                <br>                                                                      S2 change lastApplied from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                     <br>S0 applies msg&#123;Command:                                                                                                                                                     <br>%!s(<span class="hljs-type">int</span>=<span class="hljs-number">10</span>), Index: <span class="hljs-number">1</span>&#125;                                                                                                                                                      <br>S0 change lastApplied from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                                                                                           <br><br><br><br><span class="hljs-number">6.824</span>/raft.(*Raft).applyMsgToStateMachine(<span class="hljs-number">0xc0000e02d0</span>)<br><br>FAIL    <span class="hljs-number">6.824</span>/raft      <span class="hljs-number">0.767</span>s<br></code></pre></td></tr></table></figure><p>在这个场景中，S0 收到了 S1 和 S2 的投票，在第20行成为了 Leader。之后 S0 在43行发送附加日志给 S3，附加日志的请求内容为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 sends hearbeat to S1: &amp;&#123;Term:<span class="hljs-number">1</span> LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span> <br>PrevLogTerm:<span class="hljs-number">0</span> Entries:[] LeaderCommit:<span class="hljs-number">0</span>&#125; <br></code></pre></td></tr></table></figure><p>之后，S0在51行收到了客户端的请求，并添加了一条日志：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 appends a log: &#123;Command:<span class="hljs-number">10</span> Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;    <br></code></pre></td></tr></table></figure><p>接着，S0 在第109行将追加的日志发送给 S3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 sends hearbeat to S3: &amp;&#123;<br>    Term:<span class="hljs-number">1</span> LeaderId:<span class="hljs-number">0</span> PrevLogIndex:<span class="hljs-number">0</span>                                                                                                                                                   <br>    PrevLogTerm:<span class="hljs-number">0</span> Entries:[&#123;Command:<span class="hljs-number">10</span> Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                                                                                                                                     <br>    LeaderCommit:<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>但是 S3 在第118行首先收到了第二条附加日志RPC：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">S3 receives AppendEntriesRpc from S0                                                                  <br>S3 becomes Follower                                                 <br>S3 appends logs: [&#123;Command:<span class="hljs-number">10</span> Term:<span class="hljs-number">1</span> CommandIndex:<span class="hljs-number">1</span>&#125;]                                             <br>S3 changes commitIndex from <span class="hljs-number">0</span> to <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>S3 在125行才收到第一条附加日志RPC：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">S3 receives AppendEntriesRpc from S0                                                                                                       <br>S3 appends logs: []<br></code></pre></td></tr></table></figure><p>由于RPC请求的乱序到达，S3 首先会收到第二条附加日志RPC，它会追加一条日志。之后才会收到一条附加日志RPC，这这个RPC的 Entries 是空的，这回导致 S3 覆盖掉之前追加的日志。</p><p>但是 S3 此时已经将 CommitIndex 修改为1，之后 S3 会应用 ComminIndex 位置的日志到状态机中，但是对应位置的日志是空的，这就导致了错误。</p><p>很明显，在收到第一条附加日志RPC后，我们不能覆盖掉之前的追加的日志，因此在追加日志的实现中应该加一些判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">logIndex, entriesIndex := args.PrevLogIndex+<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> logIndex &lt;= rf.lastLogIndex &amp;&amp; entriesIndex &lt; <span class="hljs-built_in">len</span>(args.Entries) &amp;&amp; rf.log[logIndex<span class="hljs-number">-1</span>] == args.Entries[entriesIndex] &#123;<br>    logIndex++<br>    entriesIndex++<br>&#125;<br><span class="hljs-keyword">if</span> !(entriesIndex == <span class="hljs-built_in">len</span>(args.Entries) &amp;&amp; logIndex &lt;= rf.lastLogIndex &amp;&amp; rf.log[logIndex<span class="hljs-number">-1</span>].Term == args.Term) &#123;<br>    rf.log = <span class="hljs-built_in">append</span>(rf.log[:logIndex<span class="hljs-number">-1</span>], args.Entries[entriesIndex:]...)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们扫描发送过来的日志和本地的日志，找到第一条不匹配的日志的位置X。在之前的实现中，没有第6行的判断，直接执行第7行的追加日志操作，这可能导致已有的日志被覆盖。</p><p>如果剩下的需要追加的日志为空，并且X对应的位置存在日志，如果X对应的日志的任期与当前的 Leader 的任期号相等，说明X对应的日志是当前Leader发送过来的，那么就不应该覆盖掉它。</p><p>除了上述情况，都可以直接执行 <code>rf.log = append(rf.log[:logIndex-1], args.Entries[entriesIndex:]...)</code> 把剩下的日志复制过去。</p><p>在解决完所有 Bug 后并发跑500次测试，全部顺利通过：</p><img src="/2022/07/31/Raft-3/Raft-%E5%9B%BE5.png" class=""><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></p></li><li><p><a href="https://raft.github.io/raft.pdf">Raft paper</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>consistency</tag>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft（二）：Leader选举</title>
    <link href="/2022/07/25/Raft-2/"/>
    <url>/2022/07/25/Raft-2/</url>
    
    <content type="html"><![CDATA[<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>在多副本的分布式系统中，通常会存在一个 Primary 节点，由它来决定整个系统的决策，这样可以简化一致性的实现，因为 Priamry 只需要强迫其他节点与它保持一致即可。</p><p>但是 Primary 节点本身会发生故障，之后我们需要选出一个新的 Primary 节点，这样就可能会面临<strong>脑裂</strong>的场景。</p><p>现在我们以 VMware FT 为例，来说明为什么会出现脑裂。假设在一个网络中有两台服务器 S1 和 S2 ，这两台服务器是 Test-and-Set 服务的副本，这个网络中还有两个客户端 C1 和 C2 ，现在它们需要通过 Test-and-Set 服务确定谁是 Primary。</p><img src="/2022/07/25/Raft-2/Raft-%E5%9B%BE1.png" class=""><p>在正常情况下，Test-and-Set 服务中的数据记录从0开始。一个客户端会向两台服务器发送 Test-and-Set 指令，这个指令会把两台服务器中的数据记录设置为1，之后返回 Success 响应。如果服务器中的数据记录已经被设置，那么另一个客户端发送 Test-and-Set 指令后，则会收到一个 Fail 响应。因此，其本质上就是一个互斥锁服务。</p><p>我们希望 Test-and-Set 具有容错特性，当一个客户端只能与一个 Test-and-Set 服务器通信时，也可以正常工作。例如 C1 可以和 S1 通信，但不能和 S2 通信，C1 也可以正常工作。反之，如果 C1 必须和 S2 通信，而恰好 C1 和 S2 之间的网络出现了故障，这就导致 C1 为了等待 S2 的响应将永远无法继续工作，这就失去了多副本的意义。</p><p>因此为了具备容错特性，我们允许一个客户端只与它能连通的服务器交互。在这种情况下，如果发生了网络分区，例如 C1 只能与 S1 通信，C2 只能与 S2 通信，则会导致脑裂：</p><img src="/2022/07/25/Raft-2/Raft-%E5%9B%BE2.png" class=""><p>C1 发送 Test-and-Set 指令给 S1，S1将自己的数据记录设置为1，并返回 Success 给 C1。同时，C2 发送 Test-and-Set 指令给 S2，S2 将自己的数据记录为1，并返回 Success 给 C2。因此，C1 和 C2 都获得了 Success 响应，C1 和 C2 都会认为自己是 Primary，而不需要与另一个虚拟机进行协调，从而进入错误的场景。</p><p>因此，在这种有两个副本的服务中，我们似乎只有两种选择：要么等待两个服务器响应，那么这个时候就没有容错能力；要么只等待一个服务器响应，那么就会进入错误的场景，而这种错误的场景，通常被称为脑裂。</p><p>在上世纪八十年代，对于脑裂并没有什么好的解决办法。但是，当时又的确有多副本系统的需要，为了解决脑裂问题，有两种技术：</p><ul><li><p>构建不可能出现故障的网络。</p></li><li><p>人工解决问题，当一个服务器出现了故障，让运维人员去检查这台服务器是否真的关机了，还是出现了网络方面的故障。</p></li></ul><h2 id="过半投票"><a href="#过半投票" class="headerlink" title="过半投票"></a>过半投票</h2><p>当网络出现故障，将网络分割成两半，网络的两边独自运行，且不能访问对方，这通常被称为网络分区。而网络分区可能会导致进入上面提到的脑裂场景，从而导致多副本服务出现不一致。</p><p>随着技术的发展，人们发现即使出现分区，也能正确地实现能够自动完成故障切换的系统。在构建能自动恢复，同时又避免脑裂的多副本系统时，关键点在于<strong>过半投票</strong>。</p><p>首先服务器的数量必须是奇数，那么当出现网络分区时，必然只可能最多有一个分区拥有半数以上的服务器。我们可以规定，如果要完成任何操作，必须要凑够半数以上的服务器的投票。这样，在任何情况下只可能有一个分区能够完成操作，这也就避免了脑裂的场景。</p><p>在这种过半投票的思想的支持下，在上世纪九十年代，有两个系统被同时提出：Paxos 和 ViewStamped Replication，这两个系统都使用过半购票的原理来避免脑裂的问题。</p><h2 id="Raft-领导人选举"><a href="#Raft-领导人选举" class="headerlink" title="Raft 领导人选举"></a>Raft 领导人选举</h2><p>Raft 也应用了过半投票的思想来解决脑裂问题。Raft 会通过过半投票选举出一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。</p><p>领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p><p>具体的领导人选举算法，在 Raft 论文中说的非常详细：<a href="https://raft.github.io/raft.pdf">Raft paper</a>（第5节和5.2节）。</p><h2 id="Lab-2A-中遇到的问题"><a href="#Lab-2A-中遇到的问题" class="headerlink" title="Lab 2A 中遇到的问题"></a>Lab 2A 中遇到的问题</h2><p>最后说一说，在实现 6.824 的 LAB 2A 时遇到一个死锁 Bug。</p><p>在 6.824 的 LAB 2A 中，是需要大量使用互斥锁的，这非常容易出错。在我第一次实现完 LAB 2A 并运行测试的时候，报了大量的数据竞争错误，把这个错误改完就花了十几分钟~~。</p><p>之后继续运行测试的时候，又卡在了 “election after network failure” 的测试中，但奇怪的是整个测试并没有报错，只是“卡住了”，我就猜到可能出现了死锁。使用博客 <a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing</a> 中的测试框架，得到了如下的日志记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs go">S0 starts running                                                                                                                                                         <br>                                                          S1 starts running                                                                                               <br>                                                                                                                  S2 starts running                                       <br>S0 starts election                                                                                                                                                        <br>S0 becomes Candidate                                                                                                                                                      <br>S0 change term from <span class="hljs-number">0</span> to <span class="hljs-number">1</span>                                                                                                                                                <br>S0 votes <span class="hljs-keyword">for</span> S0                                                                                                                                                           <br>                                                          S1 receives VoteRequestRpc from S0                                                                              <br>                                                          S1 becomes Follower                                                                                             <br>                                                          S1 changes term from <span class="hljs-number">1</span> to <span class="hljs-number">1</span>                                                                                     <br>                                                          S1 votes <span class="hljs-keyword">for</span> S0                                                                                                 <br>S0 becomes Leader                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>                                                          S1 receives AppendEntriesRpc from S0                                                                            <br>                                                          S1 reply AppendEntriesRpc from S0: &amp;&#123;Term:<span class="hljs-number">1</span>&#125;                                                                    <br>                                                                                                                  S2 receives AppendEntriesRpc from S0                    <br>                                                                                                                  S2 becomes Follower                                     <br>                                                                                                                  S2 changes term from <span class="hljs-number">1</span> to <span class="hljs-number">1</span>                             <br>                                                                                                                  S2 reply AppendEntriesRpc from S0: &amp;&#123;Term:<span class="hljs-number">1</span>&#125;            <br>S0 sends hearbeat                                                                                                                                                         <br>                                                          S1 receives AppendEntriesRpc from S0                                                                            <br>                                                          S1 reply AppendEntriesRpc from S0: &amp;&#123;Term:<span class="hljs-number">1</span>&#125;                                                                    <br>                                                                                                                  S2 receives AppendEntriesRpc from S0                    <br>                                                                                                                  S2 reply AppendEntriesRpc from S0: &amp;&#123;Term:<span class="hljs-number">1</span>&#125;            <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>                                                                                                                  S2 starts election                                      <br>                                                                                                                  S2 becomes Candidate                                    <br>                                                                                                                  S2 change term from <span class="hljs-number">1</span> to <span class="hljs-number">2</span>                              <br>                                                                                                                  S2 votes <span class="hljs-keyword">for</span> S2                                         <br>                                                          S1 starts election                                                                                              <br>                                                          S1 becomes Candidate                                                                                            <br>                                                          S1 change term from <span class="hljs-number">1</span> to <span class="hljs-number">2</span>                                                                                      <br>                                                          S1 votes <span class="hljs-keyword">for</span> S1                                                                                                 <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>                                                                                                                  S2 receives VoteRequestRpc from S1                      <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>S0 sends hearbeat                                                                                                                                                         <br>                                                          S1 receives VoteRequestRpc from S2                                                                              <br>S0 sends hearbeat   <br>S0 sends hearbeat<br>S0 sends hearbeat<br>S0 sends hearbeat<br>S0 sends hearbeat<br>S0 sends hearbeat                                                                                                                                                                                          <br></code></pre></td></tr></table></figure><p>在第25到28行的记录中，可以看到 S0 发送了四次心跳，但是都没有收到 S1 和 S2 的答复，可以推测出发生了网络分区，这时候 S1 和 S2 无法与 S0 通信。</p><p>之后 S1 和 S2 触发选举超时，发起选举投票，它们首先都为自己投票，因此 S1 和 S2 都不会得到过半投票。按照理论来说，过一会之后又会触发选举超时，S1 或 S2 会再次发起选举投票，但是整个系统卡住了，只有 S0 还在打印消息。</p><p>根据上面的分析，可初步定位是在选举投票的实现中出了问题，之前的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startElection() &#123;<br>    <span class="hljs-comment">// ...........</span><br>    <span class="hljs-comment">// ...........</span><br>    <span class="hljs-comment">// ...........</span><br><br>    receivedVotes := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> rf.peers &#123;<br>        <span class="hljs-keyword">if</span> i == rf.me &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>            rf.mu.Lock()<br>            <span class="hljs-keyword">defer</span> rf.mu.Unlock()    <br>            <span class="hljs-comment">// 已经被选举成了领导人，或退化成了跟随者，直接返回</span><br>            <span class="hljs-keyword">if</span> rf.role != CANDIDATE &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 选举超时，当前节点发起新一轮选举，因此任期号改变了，直接返回</span><br>            <span class="hljs-keyword">if</span> electionStartTerm != rf.currentTerm &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            args := &amp;RequestVoteArgs&#123;<br>                Term:        electionStartTerm,<br>                CandidateId: rf.me,<br>            &#125;<br>            reply := &amp;RequestVoteReply&#123;&#125;<br>            <span class="hljs-keyword">if</span> !rf.sendRequestVote(peerId, args, reply) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// ...........</span><br>            <span class="hljs-comment">// ...........</span><br>            <span class="hljs-comment">// ...........</span><br>        &#125;(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 重置选举超时计时器</span><br>    rf.electionStart = time.Now()<br>    rf.electionTimeout = rf.randomElectionTimeout()<br>    <span class="hljs-keyword">go</span> rf.ticker()<br>&#125;    <br></code></pre></td></tr></table></figure><p>在循环中，对每个节点我们都会开一个 Go 程去“拉票”，在 Go 程最开头的时候我们申请了锁，然后使用 <code>defer rf.mu.Unlock()</code> 在 Go 程返回的时候释放锁，而这恰恰就导致了死锁。</p><p>在这个实现中，S1 和 S2 在发起投票 RPC 的时候是持有自己的锁的（假设 S1 的锁为锁A，S2 的锁为锁B）。而 S1 和 S2 在收到投票 RPC 后需要读取自己的一些状态，因此 S1 会申请锁A，S2 会申请锁B，但是此时锁A和锁B已经被 S1 和 S2 持有了，这样整个系统就卡住了，无法继续执行下去，因此 S1 和 S2 自然就不可能再次发起选举，很显然这就是一个死锁Bug。</p><p>解决方法也很简单，只要 S1 和 S2 在发起投票 RPC 之前是否释放掉持有的锁即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startElection() &#123;<br>    <span class="hljs-comment">// ...........</span><br>    <span class="hljs-comment">// ...........</span><br>    <span class="hljs-comment">// ...........</span><br><br>    receivedVotes := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> rf.peers &#123;<br>        <span class="hljs-keyword">if</span> i == rf.me &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>            rf.mu.Lock()<br>            <span class="hljs-comment">// 已经被选举成了领导人，或退化成了跟随者，直接返回</span><br>            <span class="hljs-keyword">if</span> rf.role != CANDIDATE &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 选举超时，当前节点发起新一轮选举，因此任期号改变了，直接返回</span><br>            <span class="hljs-keyword">if</span> electionStartTerm != rf.currentTerm &#123;<br>                rf.mu.Unlock()<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            rf.mu.Unlock()    <span class="hljs-comment">// 在投票前释放</span><br>            args := &amp;RequestVoteArgs&#123;<br>                Term:        electionStartTerm,<br>                CandidateId: rf.me,<br>            &#125;<br>            reply := &amp;RequestVoteReply&#123;&#125;<br>            <span class="hljs-keyword">if</span> !rf.sendRequestVote(peerId, args, reply) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// ...........</span><br>            <span class="hljs-comment">// ...........</span><br>            <span class="hljs-comment">// ...........</span><br>        &#125;(i)<br>    &#125;<br><br>    <span class="hljs-comment">// 重置选举超时计时器</span><br>    rf.electionStart = time.Now()<br>    rf.electionTimeout = rf.randomElectionTimeout()<br>    <span class="hljs-keyword">go</span> rf.ticker()<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行 Lab 2A 的测试，就能完美通过了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">Test (<span class="hljs-number">2</span>A): initial election ...<br>  ... Passed --   <span class="hljs-number">3.0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">110</span>   <span class="hljs-number">11914</span>    <span class="hljs-number">0</span><br>Test (<span class="hljs-number">2</span>A): election after network failure ...<br>  ... Passed --   <span class="hljs-number">4.5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">130</span>    <span class="hljs-number">9694</span>    <span class="hljs-number">0</span><br>Test (<span class="hljs-number">2</span>A): multiple elections ...<br>  ... Passed --   <span class="hljs-number">5.6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">852</span>   <span class="hljs-number">69742</span>    <span class="hljs-number">0</span><br>PASS<br>ok      <span class="hljs-number">6.824</span>/raft      <span class="hljs-number">14.129</span>s<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></p></li><li><p><a href="https://raft.github.io/raft.pdf">Raft paper</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>consistency</tag>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft（一）：一致性算法</title>
    <link href="/2022/07/24/Raft-1/"/>
    <url>/2022/07/24/Raft-1/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么我们需要分布式系统？"><a href="#为什么我们需要分布式系统？" class="headerlink" title="为什么我们需要分布式系统？"></a>为什么我们需要分布式系统？</h2><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。</p><p>事实上分布式系统的复杂程度通常远远超过单机系统，在单机系统中，我们可能会遇到磁盘故障、并发死锁、系统崩溃等问题，而在分布式系统中，除了这些问题外，我们还可能遇到网络延迟、分区、系统状态不一致等千奇百怪的问题。</p><p>但是，分布式系统同样具有一些好处来吸引人们使用它：</p><ul><li><p>分布式系统中存在大量的计算机并行运行，可以获取<strong>更高的性能</strong>。比如大量的计算的CPU、内存、磁盘可以并行运行。</p></li><li><p>分布式系统可以提供<strong>容错</strong>。比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另一台。</p></li><li><p>由于物理原因，有些系统天然在<strong>空间上是分布式</strong>的。例如银行转账，假设银行在相距很远的地方分别由两台服务器，如果要在这两台服务器之前进行交易转账，那么就需要一种在两者之间进行协调的方法。</p></li><li><p>实现一些<strong>安全</strong>目标。比如有一些代码不被信任，但是我们需要和它交互，这些代码不会立即表现出恶意或出现bug。我们可以把代码分散在多处运行，这样不被信任的代码在一台计算机运行，我们的代码在自己的计算机上运行，然后再通过一些特定的网络协议通信。这样就把系统分成了多个计算机，可以限制恶意代码的出错域。</p></li></ul><h2 id="通过复制实现容错"><a href="#通过复制实现容错" class="headerlink" title="通过复制实现容错"></a>通过复制实现容错</h2><p>上面提到，人们使用分布式系统的其中一个原因就是容错，而复制是实现容错的一个重要的工具。通过复制，可以让分布式系统中的节点运行相同副本，从在可以在一个节点出现故障的情况下，其他的节点可以继续提供服务。</p><p>有两种方法可以实现复制，一种是状态转移（State Transfer），另一种是复制状态机（Replicated State Machine）。</p><p>假设我们有一个服务的两个副本，一个是 Primary，另一个是 Backup。我们需要让它们保持同步，在实际上互为副本，这样一旦 Primary 出现故障，因为 Backup 的状态与 Primary 一致，就可以接管整个服务。</p><p>状态转移背后的思想是，Primary 将自己完整状态，比如说内存中的内容，拷贝并发送给Backup。Backup 会保存收到的最近一次状态，所以 Backup 会有所有的数据。当 Primary 故障了，Backup 就可以从它所保存的最新状态开始运行。所以，状态转移就是发送 Primary的状态。</p><p>复制状态机基于一个事实：我们想要复制的大部分服务都有一些确定的内部操作，而外部输入是不确定的。如果一台计算机没有外部输入，它只是一个接一个的执行指令，这样运行着相同服务的多个计算机的状态就会保持一致。只有当存在外部输入时，才可能会破坏一致性。例如，一台服务器在某个时间收到了一个网络数据包，导致服务器做一些不同的事情。</p><p>所以，复制状态机不会在不同的副本之间发送状态，相应的，它只会从 Primary 将这些外部输入发送给 Backup。假设有多台计算机，如果它们从相同的状态启动，并且以相同的顺序执行相同的外部输入，那么它们会一直互为副本，保持一致。</p><p>因此，状态转移传输的是可能是内存状态，而复制状态机会将来自客户端的操作或者其他外部输入，从 Primary 传输到 Backup。</p><h2 id="Raft-是什么？"><a href="#Raft-是什么？" class="headerlink" title="Raft 是什么？"></a>Raft 是什么？</h2><p>上面我们提到复制状态机是复制的一种实现方法，而复制状态机又通常是基于复制日志实现的，如图所示：</p><img src="/2022/07/24/Raft-1/raft-%E5%9B%BE1.png" class=""><p>每个服务器存储一个包含一系列指令的日志，并且按照日志的顺序执行指令。如果每个日志都按照相同的顺序包含相同的指令，那么每个服务器都将执行相同的指令序列，最终所有的服务其都将保持一致的状态。反过来说，如果服务器上的日志出现了不一致，比如某些服务器上缺失了一条指令，或者指令顺序与其他的服务器不一样，那么每个服务器将会执行不一样的指令序列，导致出现状态不同步的问题。</p><p>而 Raft 就是一种一致性算法，其任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a></p></li><li><p><a href="https://raft.github.io/raft.pdf">Raft paper</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>distributed system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>distributed</tag>
      
      <tag>consistency</tag>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>drop check</title>
    <link href="/2022/05/22/drop-check/"/>
    <url>/2022/05/22/drop-check/</url>
    
    <content type="html"><![CDATA[<h2 id="drop-check-x2F-may-dangle"><a href="#drop-check-x2F-may-dangle" class="headerlink" title="drop check&#x2F;may_dangle"></a>drop check&#x2F;may_dangle</h2><p>Drop checker会检查一个类型是否能够安全地实现Drop Tarit。<strong>如果一个能够安全实现Drop的类型，那么它的泛型参数的生命周期必须严格长于它本身</strong>。一个违反Drop check的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">use</span> std::ptr;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (y, x);<br>    x = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    y = MyBox::<span class="hljs-title function_ invoke__">new</span>(&amp;x);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: *<span class="hljs-keyword">mut</span> T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = System.<span class="hljs-title function_ invoke__">alloc</span>(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T;<br>            ptr::<span class="hljs-title function_ invoke__">write</span>(p, t);<br>            MyBox &#123;<br>                v: p,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.v <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _;<br>            System.<span class="hljs-title function_ invoke__">dealloc</span>(p, Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译将会发生报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0597]: `x` does not live long enough<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">13</span>:<span class="hljs-number">20</span><br>   |<br><span class="hljs-number">13</span> |     y = MyBox::<span class="hljs-title function_ invoke__">new</span>(&amp;x);<br>   |                    ^^ borrowed value does not live long enough<br><span class="hljs-number">14</span> | &#125;<br>   | -<br>   | |<br>   | `x` dropped here <span class="hljs-keyword">while</span> still borrowed<br>   | borrow might be used here, when `y` is dropped and runs the `<span class="hljs-built_in">Drop</span>` code <span class="hljs-keyword">for</span> <span class="hljs-title class_">type</span> `MyBox`<br>   |<br>   = note: values <span class="hljs-keyword">in</span> a scope are dropped <span class="hljs-keyword">in</span> the opposite order they are defined<br></code></pre></td></tr></table></figure><p>从表面上看，<code>x</code>与<code>y</code>的生命周期是一样长的。但是<code>x</code>比<code>y</code>先定义，因此变量<code>x</code>会首先发生析构，因此<code>x</code>的生命周期并不严格长于<code>y</code>的生命周期，这显然不满足Drop checker的条件，因此发生报错：编译器认为在调用<code>y</code>的析构函数时，可能会使用<code>x</code>的引用，这会导致UB，因此编译器拒绝这段代码。</p><p>但是，实际上我们并没有在<code>y</code>的析构函数使用<code>x</code>的引用，不会出现UB行为。为了解决这个问题，可以开启特性<code>#![feature(dropck_eyepatch)]</code>，并使用属性<code>#[may_dangle]</code>注解<code>T</code>，明确表示不会在<code>y</code>的析构函数中使用<code>x</code>的引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-meta">#![feature(dropck_eyepatch)]</span><br><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">use</span> std::ptr;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (y, x);<br>    x = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    y = MyBox::<span class="hljs-title function_ invoke__">new</span>(&amp;x);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: *<span class="hljs-keyword">mut</span> T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = System.<span class="hljs-title function_ invoke__">alloc</span>(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T;<br>            ptr::<span class="hljs-title function_ invoke__">write</span>(p, t);<br>            MyBox &#123;<br>                v: p,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.v <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _;<br>            System.<span class="hljs-title function_ invoke__">dealloc</span>(p, Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译将会顺利通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">Compiling playground v0.<span class="hljs-number">0.1</span> (/playground)<br>    Finished dev [unoptimized + debuginfo] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">7.20</span>s<br>     Running `target/debug/playground`<br></code></pre></td></tr></table></figure><h2 id="phantomData"><a href="#phantomData" class="headerlink" title="phantomData"></a>phantomData</h2><p>使用<code>may_dangle</code>后编译器将不会进行Drop check检查，但是在下面的代码中将会出现UB：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-meta">#![feature(dropck_eyepatch)]</span><br><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">use</span> std::ptr;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (y, x);<br>    x = Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">13</span>);<br>    y = MyBox::<span class="hljs-title function_ invoke__">new</span>(Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;y&quot;</span>, &amp;x));<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    Invalid,<br>    Valid,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt;(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, T, State);<br><br><span class="hljs-keyword">impl</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt; Hello&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Hello</span>(name, t, State::Valid)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Hello</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Drop hello(&#123;&#125;, &#123;:?&#125;, &#123;:?&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span> = State::Invalid;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: *<span class="hljs-keyword">mut</span> T,<br>    <span class="hljs-comment">// _pd: PhantomData&lt;T&gt;</span><br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = System.<span class="hljs-title function_ invoke__">alloc</span>(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T;<br>            ptr::<span class="hljs-title function_ invoke__">write</span>(p, t);<br>            MyBox &#123;<br>                v: p,<br>                <span class="hljs-comment">// _pd: PhantomData</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.v <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _;<br>            System.<span class="hljs-title function_ invoke__">dealloc</span>(p, Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">Drop</span> <span class="hljs-title function_ invoke__">hello</span>(x, <span class="hljs-number">13</span>, Valid)<br><span class="hljs-built_in">Drop</span> <span class="hljs-title function_ invoke__">hello</span>(y, <span class="hljs-title function_ invoke__">Hello</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">13</span>, Invalid), Valid)<br></code></pre></td></tr></table></figure><p>使用MIRI检查是否存在UB：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust">error: Undefined Behavior: pointer to alloc999 was dereferenced after this allocation got freed<br>    -<span class="hljs-punctuation">-&gt;</span> /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">2116</span>:<span class="hljs-number">1</span><br>     |<br><span class="hljs-number">2116</span> | fmt_refs! &#123; <span class="hljs-built_in">Debug</span>, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp &#125;<br>     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer to alloc999 was dereferenced after this allocation got freed<br>     |<br>     = help: this indicates a bug <span class="hljs-keyword">in</span> the program: it performed an invalid operation, and caused Undefined Behavior<br>     = help: see https:<span class="hljs-comment">//doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information</span><br><br>     = note: inside `&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">as</span> std::fmt::<span class="hljs-built_in">Debug</span>&gt;::fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">2106</span>:<span class="hljs-number">71</span><br>     = note: inside `std::fmt::write` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">1168</span>:<span class="hljs-number">17</span><br>     = note: inside `&lt;std::io::StdoutLock <span class="hljs-keyword">as</span> std::io::Write&gt;::write_fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">1653</span>:<span class="hljs-number">15</span><br>     = note: inside `&lt;&amp;std::io::Stdout <span class="hljs-keyword">as</span> std::io::Write&gt;::write_fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:<span class="hljs-number">844</span>:<span class="hljs-number">9</span><br>     = note: inside `&lt;std::io::Stdout <span class="hljs-keyword">as</span> std::io::Write&gt;::write_fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:<span class="hljs-number">818</span>:<span class="hljs-number">9</span><br>     = note: inside `std::io::stdio::print_to::&lt;std::io::Stdout&gt;` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:<span class="hljs-number">1186</span>:<span class="hljs-number">21</span><br>     = note: inside `std::io::_print` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:<span class="hljs-number">1199</span>:<span class="hljs-number">5</span><br>note: inside `&lt;Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt; <span class="hljs-keyword">as</span> std::ops::<span class="hljs-built_in">Drop</span>&gt;::drop` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/macros.rs:<span class="hljs-number">99</span>:<span class="hljs-number">9</span><br>    -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">32</span>:<span class="hljs-number">9</span><br>     |<br><span class="hljs-number">32</span>   |         <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Drop hello(&#123;&#125;, &#123;:?&#125;, &#123;:?&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span>);<br>     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br>     = note: inside `std::ptr::drop_in_place::&lt;Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt;&gt; - <span class="hljs-title function_ invoke__">shim</span>(<span class="hljs-title function_ invoke__">Some</span>(Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt;))` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">188</span>:<span class="hljs-number">1</span><br>note: inside `&lt;MyBox&lt;Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt;&gt; <span class="hljs-keyword">as</span> std::ops::<span class="hljs-built_in">Drop</span>&gt;::drop` at src/main.rs:<span class="hljs-number">59</span>:<span class="hljs-number">13</span><br>    -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">59</span>:<span class="hljs-number">13</span><br>     |<br><span class="hljs-number">59</span>   |             ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^<br>     = note: inside `std::ptr::drop_in_place::&lt;MyBox&lt;Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt;&gt;&gt; - <span class="hljs-title function_ invoke__">shim</span>(<span class="hljs-title function_ invoke__">Some</span>(MyBox&lt;Hello&lt;&amp;Hello&lt;<span class="hljs-type">i32</span>&gt;&gt;&gt;))` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">188</span>:<span class="hljs-number">1</span><br>note: inside `main` at src/main.rs:<span class="hljs-number">13</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>之所以会出现上述结果，是因为在<code>y</code>的析构函数中，我们调用了<code>T: Hello::new(&quot;y&quot;, &amp;x)</code>的析构函数，在<code>T</code>的析构函数中会打印<code>&amp;x</code>的值，而<code>x</code>在此时已经被析构了，它的值变成了<code>Hello(x,13,Invalid)</code>。因此<code>y</code>中的<code>&amp;x</code>变成了悬垂引用，并且在<code>T</code>的析构函数中使用了<code>&amp;x</code>，这显然是一种UB。</p><p>为了防止UB，我们可以在<code>MyBox</code>中添加<code>PhantomData</code>字段，表示<code>MyBox</code>拥有<code>T</code>，会在<code>MyBox</code>的析构函数中析构<code>T</code>（当然<code>MyBox</code>并不拥有<code>T</code>，也不一定会析构<code>T</code>），告诉编译器对<code>MyBox</code>进行Drop check检查。</p><p>修改上述代码，添加<code>PhantomData</code>字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-meta">#![feature(dropck_eyepatch)]</span><br><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">use</span> std::ptr;<br><span class="hljs-keyword">use</span> std::marker::PhantomData;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (y, x);<br>    x = Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">13</span>);<br>    y = MyBox::<span class="hljs-title function_ invoke__">new</span>(Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;y&quot;</span>, &amp;x));<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    Invalid,<br>    Valid,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt;(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, T, State);<br><br><span class="hljs-keyword">impl</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt; Hello&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Hello</span>(name, t, State::Valid)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Hello</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Drop hello(&#123;&#125;, &#123;:?&#125;, &#123;:?&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span> = State::Invalid;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: *<span class="hljs-keyword">mut</span> T,<br>    _pd: PhantomData&lt;T&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = System.<span class="hljs-title function_ invoke__">alloc</span>(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T;<br>            ptr::<span class="hljs-title function_ invoke__">write</span>(p, t);<br>            MyBox &#123;<br>                v: p,<br>                _pd: PhantomData<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.v <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _;<br>            System.<span class="hljs-title function_ invoke__">dealloc</span>(p, Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译将会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0597]: `x` does not live long enough<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">13</span>:<span class="hljs-number">36</span><br>   |<br><span class="hljs-number">13</span> |     y = MyBox::<span class="hljs-title function_ invoke__">new</span>(Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;y&quot;</span>, &amp;x));<br>   |                                    ^^ borrowed value does not live long enough<br><span class="hljs-number">14</span> | &#125;<br>   | -<br>   | |<br>   | `x` dropped here <span class="hljs-keyword">while</span> still borrowed<br>   | borrow might be used here, when `y` is dropped and runs the `<span class="hljs-built_in">Drop</span>` code <span class="hljs-keyword">for</span> <span class="hljs-title class_">type</span> `MyBox`<br>   |<br>   = note: values <span class="hljs-keyword">in</span> a scope are dropped <span class="hljs-keyword">in</span> the opposite order they are defined<br></code></pre></td></tr></table></figure><p>这表明Drop checker起了作用，有效防止出现UB。</p><p>但是，这似乎与最初版的代码的编译是一样的，那要<code>PhantomData</code>和<code>may_dangle</code>有什么用？答案当然是有用的，如果<code>MyBox&lt;T&gt;</code>中的<code>T</code>没有实现Drop trait，那么上述代码将会编译通过。</p><p>删除<code>Hello</code>的析构函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-meta">#![feature(dropck_eyepatch)]</span><br><span class="hljs-keyword">use</span> std::alloc::&#123;GlobalAlloc, Layout, System&#125;;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-keyword">use</span> std::ptr;<br><span class="hljs-keyword">use</span> std::marker::PhantomData;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (y, x);<br>    x = Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">13</span>);<br>    y = MyBox::<span class="hljs-title function_ invoke__">new</span>(Hello::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;y&quot;</span>, &amp;x));<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    Invalid,<br>    Valid,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt;(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, T, State);<br><br><span class="hljs-keyword">impl</span>&lt;T: fmt::<span class="hljs-built_in">Debug</span>&gt; Hello&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>, t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Hello</span>(name, t, State::Valid)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: *<span class="hljs-keyword">mut</span> T,<br>    _pd: PhantomData&lt;T&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = System.<span class="hljs-title function_ invoke__">alloc</span>(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T;<br>            ptr::<span class="hljs-title function_ invoke__">write</span>(p, t);<br>            MyBox &#123;<br>                v: p,<br>                _pd: PhantomData<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;<span class="hljs-meta">#[may_dangle]</span> T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ptr::<span class="hljs-title function_ invoke__">drop_in_place</span>(<span class="hljs-keyword">self</span>.v);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-keyword">self</span>.v <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _;<br>            System.<span class="hljs-title function_ invoke__">dealloc</span>(p, Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译将会通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">Compiling playground v0.<span class="hljs-number">0.1</span> (/playground)<br>   Finished dev [unoptimized + debuginfo] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">1.53</span>s<br>    Running `target/debug/playground`<br></code></pre></td></tr></table></figure><p>这是因为，如果<code>MyBox&lt;T&gt;</code>中的<code>T</code>没有实现<code>Drop Trait</code>，就算<code>T</code>中存在悬垂引用，也不可能在<code>MyBox</code>的析构函数中通过<code>T</code>的析构函数访问这个悬垂引用，因此不会出现UB，</p><p>如果不使用<code>may_dangle</code>和<code>PhantomData</code>，那么即使<code>T</code>没有实现Drop trait，代码也不会通过编译，即编译器会拒绝掉正确的代码，这显然不是我们所期望的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，<code>may_dangle</code>和<code>PhantomData</code>结合使用将会有如下效果：</p><ul><li>如果<code>MyBox&lt;T&gt;</code>中的<code>T</code>实现了Drop Trait，那么Drop Checker会要求<code>T</code>的生命周期严格长于<code>MyBox</code>；</li><li>如果<code>MyBox&lt;T&gt;</code>中的<code>T</code>没有实现Drop Trait，那么Drop Checker不会会要求<code>T</code>的生命周期严格长于<code>MyBox</code>。</li></ul><p>如果没有使用<code>may_dangle</code>和<code>PhantomData</code>，那么无论<code>T</code>有没有实现Drop Trait，Drop Checker都会要求<code>T</code>的生命周期严格长于<code>MyBox</code>。</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/383004091">https://zhuanlan.zhihu.com/p/383004091</a></li><li><a href="https://stackoverflow.com/questions/42708462/why-is-it-useful-to-use-phantomdata-to-inform-the-compiler-that-a-struct-owns-a">https://stackoverflow.com/questions/42708462/why-is-it-useful-to-use-phantomdata-to-inform-the-compiler-that-a-struct-owns-a</a></li><li>来自群友的答疑解惑😀</li></ul>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/22/hello-world/"/>
    <url>/2022/05/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
