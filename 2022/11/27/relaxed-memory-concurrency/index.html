

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta name="google-site-verification" content="NutVL4Scy7H0J8keF3k0QjqlIRLdXafMMiMg6ZhF5CQ" />
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Night Cruise">
  <meta name="keywords" content="">
  
    <meta name="description" content="A promising semantics for relaxed memory concurrency">
<meta property="og:type" content="article">
<meta property="og:title" content="Relaxed Memory Concurrency">
<meta property="og:url" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/index.html">
<meta property="og:site_name" content="阿愁">
<meta property="og:description" content="A promising semantics for relaxed memory concurrency">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-4.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/message-adjacency-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/message-adjacency-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/message-adjacency-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-thread-view-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-message-view-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-message-view-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-message-view-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-message-view-4.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/per-message-view-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-4.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/global-view-6.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-6.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-7.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-8.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-9.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-10.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-11.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-1-12.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-2-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-6.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-7.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-8.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-9.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-10.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-11.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-3-12.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-4-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-4-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-4-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-4-4.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/promises-4-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-1.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-2.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-3.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-4.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-5.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-6.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-7.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-8.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/spin-lock-9.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/ticket-lock.png">
<meta property="og:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/clh-lock.png">
<meta property="article:published_time" content="2022-11-27T15:43:53.000Z">
<meta property="article:modified_time" content="2022-12-05T17:11:12.783Z">
<meta property="article:author" content="Night Cruise">
<meta property="article:tag" content="consistency">
<meta property="article:tag" content="rust">
<meta property="article:tag" content="note">
<meta property="article:tag" content="lock-free">
<meta property="article:tag" content="concurrent">
<meta property="article:tag" content="relaxed memory">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/multi-value-memory-1.png">
  
  
  
  <title>Relaxed Memory Concurrency - 阿愁</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"night-cruise.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>阿愁</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Relaxed Memory Concurrency"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-27 23:43" pubdate>
          2022年11月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          149 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Relaxed Memory Concurrency</h1>
            
            <div class="markdown-body">
              
              <p>内存一致性模型是是系统和程序员之间的规范，它规定了在一个共享存储器的多线程程序中的存储访问应该表现出怎样的行为。内存模型由以下两个属性组成：</p>
<ul>
<li><p>Memory Ordering</p>
<ul>
<li>Load-Load Order：不同地址上的读操作是否会乱序；</li>
<li>Load-Store Order：读操作和后面另一个地址上的写操作是否会乱序；</li>
<li>Store-Load Order：写操作和后面的读操作是否会乱序；</li>
<li>Store-Store Order：不同地址上的写操作是否会乱序；</li>
<li>Dependent Loads Order：当第二条读操作的地址取决于前一条读操作的结果时，是否会乱序。</li>
</ul>
</li>
<li><p>Store Atomicity（处理器的写操作是否会被所有处理器看到）</p>
<ul>
<li>Load Other’s Store Early &amp;&amp; Non-Causality：允许写操作被自己及个别其他处理器先看到，不支持 Causality。写序列可能以不同顺序被多个处理器观察到；</li>
<li>Load Other’s Store Early &amp;&amp; Causality：允许写操作被自己及个别其他处理器先看到，支持 Causality；</li>
<li>Load Own Store Early：只允许写操作被自己先看到。写序列以相同顺序被多个处理器观察到；</li>
<li>Atomic Store：所有处理器同时看到写操作。</li>
</ul>
</li>
</ul>
<p>最符合程序员直觉的是 SC（Sequential Consistency） Model，即所有的线程以交错的方式访问内存，并且在单个线程中访问内存的顺序与代码的执行顺序一致。这意味着，一个线程执行的操作对随后执行的线程可见，并且所有的线程都会看到一个相同的操作顺序。SC 的 Memory Model 属性：</p>
<ul>
<li>LL&#x2F;LS&#x2F;SL&#x2F;SS&#x2F;DL 乱序：不允许；</li>
<li>Store Atomicity：Load Own Store Early。</li>
</ul>
<p>在 SC Model 的基础上，逐步放松各个属性的限制，会依次得到各种弱一致性模型，可以统称为 Relaxed Memory Model。</p>
<blockquote>
<p>以上内容来自：<a target="_blank" rel="noopener" href="https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md">https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md</a></p>
</blockquote>
<p>本文是 <a target="_blank" rel="noopener" href="https://github.com/kaist-cp/cs431">CS431</a> 的学习笔记，记录了 Relaxed Memory Model 的 promising semantics 的原理和验证自旋锁实现正确性的例子。</p>
<h2 id="the-nondeterminism-due-to-shared-memory-accesses"><a href="#the-nondeterminism-due-to-shared-memory-accesses" class="headerlink" title="the nondeterminism due to shared memory accesses"></a>the nondeterminism due to shared memory accesses</h2><p>在基于共享内存实现的多线程并发程序中，执行结果常常具备大量的不确定性，不确定来源主要有两个：thread interleaving 和 instruction reordering。</p>
<h3 id="thread-interleaving"><a href="#thread-interleaving" class="headerlink" title="thread interleaving"></a>thread interleaving</h3><p>thread interleaving 指的是多线程的 Load&#x2F;Store 指令交替执行，导致执行结果的不确定性。例如下面这段程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>            X = a;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>            X = b;<br>        &#125;<br>    &#125;);<br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;X = &#123;&#125;&quot;</span>, X);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 <code>handle1</code> 线程先执行，那么 <code>X = 1</code>；如果 <code>handle2</code> 线程先执行，那么 <code>X = 2</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs r">PS C<span class="hljs-operator">:</span><span class="hljs-punctuation">\</span>Users<span class="hljs-punctuation">\</span><span class="hljs-number">25864</span><span class="hljs-punctuation">\</span>Desktop<span class="hljs-punctuation">\</span>relaxed_memory_concurrency<span class="hljs-operator">&gt;</span> cargo run<br>    Finished dev <span class="hljs-punctuation">[</span>unoptimized <span class="hljs-operator">+</span> debuginfo<span class="hljs-punctuation">]</span> target<span class="hljs-punctuation">(</span>s<span class="hljs-punctuation">)</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s<br>     Running `target\debug\relaxed_memory_concurrency.exe`<br>X <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>PS C<span class="hljs-operator">:</span><span class="hljs-punctuation">\</span>Users<span class="hljs-punctuation">\</span><span class="hljs-number">25864</span><span class="hljs-punctuation">\</span>Desktop<span class="hljs-punctuation">\</span>relaxed_memory_concurrency<span class="hljs-operator">&gt;</span> cargo run<br>    Finished dev <span class="hljs-punctuation">[</span>unoptimized <span class="hljs-operator">+</span> debuginfo<span class="hljs-punctuation">]</span> target<span class="hljs-punctuation">(</span>s<span class="hljs-punctuation">)</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s<br>     Running `target\debug\relaxed_memory_concurrency.exe`<br>X <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>thread interleaving 产生的不确定性非常容易推断，这也是我们所期望的，通过 thread interleaving 可以显著提高程序的性能。</p>
<h3 id="reordering"><a href="#reordering" class="headerlink" title="reordering"></a>reordering</h3><p>reordering 指的是 Load&#x2F;Store 指令被重排序，导致出现不符合直觉的执行结果。硬件和编译器会执行一些优化，只要不是访问相同的内存位置，任何 Load&#x2F;Store&#x2F;RMW 指令都可能会被重排序。例如下面这段程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;		||		<span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>() == <span class="hljs-number">1</span> &#123;<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>);	||			<span class="hljs-built_in">assert_eq!</span>(DATA, <span class="hljs-number">42</span>);<br>				||      &#125;<br></code></pre></td></tr></table></figure>

<p>假设只存在 thread interleaving：</p>
<ul>
<li>线程2先执行 <code>if FLAG.load() == 1</code>，而此时 <code>FLAG = 0</code>，那么就不会执行 <code>assert_eq!(DATA, 42)</code>，程序运行正常；</li>
<li>线程1先执行 <code>DATA = 42; FLAG.store(1)</code>，然后线程后执行 <code>if FLAG.load() == 1</code>，此时 <code>FLAG = 1</code>，因此会进行 if 分支执行 <code>assert_eq!(DATA, 42)</code>，因为 <code>DATA = 42</code> 已经被执行了，因此断言不会失败，程序继续运行。</li>
</ul>
<p>可见，如果只存在 thread interleaving，那么上面的程序一定不会执行失败。但是，由于存在 reordering，<code>assert_eq!(DATA, 42)</code> 断言有可能会失败：</p>
<ul>
<li>Store hoisting：线程1中的 <code>FLAG.store(1)</code> 先执行，然后线程2执行 <code>if</code> 判断成功，之后执行 <code>assert_eq!(DATA, 42)</code> 断言就会失败，因为此时 <code>DATA = 0</code>；</li>
<li>Load hoisting：线程2中的 <code>assert_eq!(DATA, 42)</code> 先执行，此时 <code>DATA = 0</code>，因此断言失败，程序崩溃。</li>
</ul>
<p>我们把硬件&#x2F;编译器 reordering 导致的 unintended behaviors 统称为 relaxed behaviors，relaxed behaviors 无法在 thread interleaving 语义中观测到。</p>
<h3 id="solution-for-relaxed-behaviors-amp-orderings"><a href="#solution-for-relaxed-behaviors-amp-orderings" class="headerlink" title="solution for relaxed behaviors &amp; orderings"></a>solution for relaxed behaviors &amp; orderings</h3><p>可以使用 ordering primitives 禁止 reordering，从而避免出现 relaxed behaviors：</p>
<ul>
<li><p>Access ordering：使用 <code>Release/Acquire</code> synchronization。</p>
</li>
<li><p>Fence：在 Store&#x2F;Load 之间插入 <code>fence(SC)</code>；</p>
</li>
</ul>
<p>（1）使用  <code>Release/Acquire</code> synchronization：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;                ||   <span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(acquire) == <span class="hljs-number">1</span> &#123;<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, release);   ||       <span class="hljs-title function_ invoke__">assert</span>(DATA == <span class="hljs-number">42</span>);<br>                          ||   &#125;<br></code></pre></td></tr></table></figure>

<p>Release Store：禁止与 Store 之前的指令重排序；Acquire Load：禁止与 LOAD 之后的指令重排序。因此只要 <code>FLAG.load(acquire) == 1</code>，那么 <code>assert(DATA == 42)</code> 断言一定会成功。</p>
<p>（2）使用 <code>fence(SC)</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA = <span class="hljs-number">42</span>;                ||   <span class="hljs-keyword">if</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(relaxed) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-title function_ invoke__">fence</span>(SC);                ||       <span class="hljs-title function_ invoke__">fence</span>(SC);<br>FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, relaxed);   ||       <span class="hljs-title function_ invoke__">assert</span>(DATA == <span class="hljs-number">42</span>);  &#125;<br></code></pre></td></tr></table></figure>

<p>SC fence：禁止重排序 SC fence 之前和之后的指令。那么，只要 <code>FLAG.load(acquire) == 1</code>，那么 <code>assert(DATA == 42)</code> 断言一定会成功。</p>
<p>但是 relaxed behaviors &amp; orderings 的精确含义是什么？到底什么行为是被允许的、什么行为是不被允许的？为了推断并发程序的正确性，我们需要为 relaxed behaviors &amp; orderings 找到一个好的语义。</p>
<h2 id="promising-semantics"><a href="#promising-semantics" class="headerlink" title="promising semantics"></a>promising semantics</h2><p><a target="_blank" rel="noopener" href="https://sf.snu.ac.kr/promise-concurrency/">promising semantics</a> 是一种 Relaxed Memory Model，对 relaxed behaviors &amp; orderings 进行建模。它有下面的四个 Key idea：</p>
<ul>
<li>modeling load hoisting w&#x2F; <strong>multi-valued memory</strong>：Allowing a thread to read an old value from a location；</li>
<li>modeling read-modify-write w&#x2F; <strong>message adjacency</strong>：Forbidding multiple read-modify-writes of a single value；</li>
<li>modeling coherence &amp; ordering w&#x2F; <strong>views</strong>：Constraining a thread’s behavior；</li>
<li>modeling store hoisting w&#x2F; <strong>promises</strong>：Allowing a thread to speculatively write a value。</li>
</ul>
<h3 id="multi-valued-memory"><a href="#multi-valued-memory" class="headerlink" title="multi-valued memory"></a>multi-valued memory</h3><p>在 promising semantics 中内存是 location 到 list message 的映射，message 由 value 和 timestamp 组成。因此线程可以从一个 location 读取一个 old value。</p>
<p>multi-values memory 的目的是为 load hoisting 建模，例如 Load hoisting（r1&#x3D;r2&#x3D;0 allowed by reading old values from X and Y）：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-1.png" srcset="/img/loading.gif" lazyload class="">

<p>假设线程1先执行 <code>X = 1</code>，插入一条 <code>X = 1</code> 的 message：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>Y = 1</code>，插入一条 <code>Y = 1</code> 的 message：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-3.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>r1 = Y</code>，可以读到 <code>Y = 0</code> message，因此 <code>r1 = 0</code>：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-4.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2 = X</code>，可以读到 <code>X = 0</code> message，因此 <code>r2 = 0</code>：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/multi-value-memory-5.png" srcset="/img/loading.gif" lazyload class="">

<p>综上所述，在 multi-value memory 中，从 <code>X</code> 和 <code>Y</code> 中可以读取 old value，<code>r1 = r2 = 0</code> 是可以出现的。</p>
<p>从 reordering 的角度考虑，线程1中的 <code>X = 1; r1 = Y</code> 可以被重排序，线程2中的 <code>Y = 1; r2 = X</code> 可以被重排序，因此 <code>r1 = r2 = 0</code> 可以出现，这也被称为 load hoisting。</p>
<p>在 x86 平台中，允许 Store-Load 重排序，因此可以用下面这段真实的程序验证 load hoisting：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> R1: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> R2: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> Y: <span class="hljs-type">i32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = <span class="hljs-number">2000000</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..total &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">test_load_hoisting</span>() &#123;<br>            count += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;load hoisting happens &#123;count&#125; times in &#123;total&#125; running.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_load_hoisting</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            X = <span class="hljs-number">1</span>;<br>            R1 = Y;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            Y = <span class="hljs-number">1</span>;<br>            R2 = X;<br>        &#125;<br>    &#125;);<br>    <br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = R1 == <span class="hljs-number">0</span> &amp;&amp; R2 == <span class="hljs-number">0</span>;<br>        R1 = <span class="hljs-number">0</span>;<br>        R2 = <span class="hljs-number">0</span>;<br>        X = <span class="hljs-number">0</span>;<br>        Y = <span class="hljs-number">0</span>;<br><br>        res<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行2000000次，发生了1次重排序：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">PS C:\Users\<span class="hljs-number">25864</span>\Desktop\relaxed_memory_concurrency&gt; cargo <span class="hljs-built_in">run</span> <span class="hljs-comment">--release</span><br>   <br>load hoisting happens <span class="hljs-number">1</span> <span class="hljs-keyword">times</span> <span class="hljs-keyword">in</span> <span class="hljs-number">2000000</span> <span class="hljs-built_in">running</span>.<br></code></pre></td></tr></table></figure>



<h3 id="message-adjacency"><a href="#message-adjacency" class="headerlink" title="message adjacency"></a>message adjacency</h3><p>为了对 read-modify-write 指令进行建模，需要对 message 增加限制，在 multi-value memory 中 message 的 timestamp 仅仅只一个点，而在 message adjacency 中 message 的 timestamp 具有范围。</p>
<p>message adjacency 对 RMW 指令进行建模，在执行 Read-Modify-writes 指令时，应该把一个新的 message 邻接到旧的 message 右边。例如 counter（r1&#x3D;r2&#x3D;0 forbidden）：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>r1 = X.fetch_add(1)</code>，将 <code>X = 1</code> 的 message 邻接到 <code>X = 0</code> 的 message 的右边，此时 <code>r1 = 0</code>：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2 = X.fetch_add(1)</code>，因为 <code>X = 0</code> 这条 message 已经被邻接了，因此 <code>X = 2</code> message 只能邻接到 <code>X = 1</code> message 的右边，因此只能读到 <code>X = 1</code> message，此时 <code>r2 = 1</code>：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/message-adjacency-3.png" srcset="/img/loading.gif" lazyload class="">

<p>综上所述，<code>r1 = r2 = 0</code> 结果不可能出现，符合 RMW 指令的语义。</p>
<h3 id="views"><a href="#views" class="headerlink" title="views"></a>views</h3><p>multi-valued memory 允许太多的 unintended behaviors，当涉及到 coherence 和 synchronization 时需要增加限制。view 是 location 到 timestamp 的映射，表示 message 的确认。一共有三种 view：</p>
<ul>
<li><strong>Per-thread</strong> <strong>view</strong> for coherence；</li>
<li><strong>Per-message view</strong> for release&#x2F;acquire synchronization；</li>
<li><strong>A global view</strong> for SC synchronization。</li>
</ul>
<h4 id="Per-thread-view"><a href="#Per-thread-view" class="headerlink" title="Per-thread view"></a>Per-thread view</h4><p>Per-thread view 表示一个线程对 message 的确认，要求 reading&#x2F;writing 发生在当前线程的 view 之后，并且 reading&#x2F;writing 会改变当前线程的 view。</p>
<p>Per-thread view 用于建模 per-location coherence：</p>
<ul>
<li>RR coherence：X&#x3D;1 || r1&#x3D;X; r2&#x3D;X [r1&#x3D;1,r2&#x3D;0 impossible]</li>
<li>RW coherence:：r&#x3D;X; X&#x3D;1 [r&#x3D;0]</li>
<li>WR coherence:：X&#x3D;1; r&#x3D;X [r&#x3D;1]</li>
<li>WW coherence:：X&#x3D;1; X&#x3D;2 [X&#x3D;2 at the end]</li>
</ul>
<img src="/2022/11/27/relaxed-memory-concurrency/per-thread-view-1.png" srcset="/img/loading.gif" lazyload class="">

<p>以 WR coherence为例，执行代码 <code>X=1; r=X </code>：初始的线程 view 为 X &#x3D; 0 &amp; Y &#x3D; 0，当执行 <code>X = 1</code> 时，会插入一条 <code>X = 1</code> message，之后线程 view 变为 X &#x3D; 1 &amp; Y &#x3D; 0，此时再执行 <code>r = X</code>，由于 reading&#x2F;writing 只能发生在当前线程的 view 之后，因此一定会有 <code>r = 1</code>。这样就完成了对 WR coherence 的建模。</p>
<h4 id="Per-message-view"><a href="#Per-message-view" class="headerlink" title="Per-message view"></a>Per-message view</h4><p>Per-message view 表示执行 <code>AtomicType.store(T, release)</code> 产生的 released view，用于建模 release&#x2F;acquire synchronization。例如 message passing （X&#x3D;1 should be acknowledged after reading Y&#x3D;1）：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>X = 1</code>，插入 <code>X=1</code> message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>Y.store(1, release)</code>，插入 <code>Y=1</code> message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1，由于使用了 release，生成了一个 message view：X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-3.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>Y.load(acquire)</code>，假设线程2读到 <code>Y=1</code> message，线程2的视图变为 X &#x3D; 0 &amp; Y &#x3D; 1，由于使用了 acquire，message view 会合并到线程2的 view 中，因此线程2的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-4.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>assert(X == 1);</code>，此时线程2的 view 为 X &#x3D; 1 &amp; Y &#x3D; 1，因此会读取 X&#x3D;1 message，断言执行成功：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/per-message-view-5.png" srcset="/img/loading.gif" lazyload class="">

<p>可以看出，通过 Release&#x2F;Acquire 的使用，可以实现 message 在不同线程之间的传递。</p>
<h4 id="Global-view"><a href="#Global-view" class="headerlink" title="Global view"></a>Global view</h4><p>Global view 表示 SC fence 的当前累积 view，在一个 SC fence 之后，SC view 和 thread view 成为它们之中的最大者。Global view 用于建模 SC-fence synchronization，例如 message passing （X&#x3D;1 should be acknowledged after reading Y&#x3D;1）：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>X = 1</code>，插入 X &#x3D; 1 message，线程1的 view 变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>fence(SC)</code>，SC view 和 thread1 view 成为它们之间的最大者，因为此时 SC view 不存在，因此 thread1 view 保持不变，SC view 变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-3.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>Y.store(1, relaxed)</code>，插入 Y &#x3D; 1 message，线程1的 view 变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-4.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>Y.load(relaxed)</code>，假设线程2读到 Y &#x3D; 1 message，线程2的 view 变为 X &#x3D; 0 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-5.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>fence(SC)</code>，SC view 和 thread2 view 成为它们之间的最大者，因此 thread2 view 变为 X &#x3D; 1 &amp; Y &#x3D; 1，SC view 变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/global-view-6.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>assert(X == 1)</code>，此时线程2的 view 为 X &#x3D; 1 &amp; Y &#x3D; 1，因此线程2会读到 X &#x3D; 1 message，断言执行成功。</p>
<p>总结：通过 SC fence 的使用，也可以实现 message 在不同线程之间的传递。</p>
<h3 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h3><h4 id="Store-hoisting"><a href="#Store-hoisting" class="headerlink" title="Store hoisting"></a>Store hoisting</h4><p>与 load hoisting、RMW、coherence、synchronization 不同，store hoisting 更为复杂，涉及到以下三种情况：</p>
<p>（1）Store hoisting w&#x2F;o dependency（r1&#x3D;r2&#x3D;1 allowed by reordering in the right）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    X=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>线程2中 X 写入的值不依赖于其他指令，由于 Load-Store reordering，可以观察到 r1 &#x3D; r2 &#x3D; 1。</p>
<p>（2）Store hoisting w&#x2F; dependency（r1&#x3D;r2&#x3D;1 disallowed, “out of thin air” (OOTA)）</p>
<p>线程2中 X 写入的值依赖于上一条指令读取的值，此时不允许观察到 r1 &#x3D; r2 &#x3D; 1。如果 r1 &#x3D; r2 &#x3D; 1，则出现了 OOTA（out of thin air）behavior，那么我们将无法推断并发程序的正确性。</p>
<p>（3）Store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;1 allowed by compiler opt）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    <span class="hljs-keyword">if</span> r2==<span class="hljs-number">1</span>  &#123; X=r2 &#125;   <span class="hljs-comment">// “if” should be taken for the behavior,</span><br>              <span class="hljs-keyword">else</span>       &#123; X=<span class="hljs-number">1</span>  &#125;   <span class="hljs-comment">// but looks like OOTA</span><br></code></pre></td></tr></table></figure>

<p>从表面上来看，线程2中 X 写入的值依赖于上一条指令，但是<code>if r2 == 1 &#123; X = r2 &#125; else &#123; X = 1 &#125;</code> 无论执行哪个分治都有 <code>X = 1</code>，因此编译器可能会将其直接优化成：<code>X = 1</code>，这样就变成了情况（1）了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">r1=X    ||    r2=Y<br>Y=r1    ||    X=<span class="hljs-number">1</span>		<span class="hljs-comment">// if r2 == 1 &#123; X = r2 &#125; else &#123; X = 1 &#125;</span><br></code></pre></td></tr></table></figure>

<p>优化之后的代码，线程2写入的值不依赖于其他指令，由于 Load-Store reordering，也可以观察到 r1 &#x3D; r2 &#x3D; 1。</p>
<p>这里的难点就是，我们需要找到一个好的 semantic model，其允许（1）和（3）但是不允许（2）。</p>
<h4 id="modeling"><a href="#modeling" class="headerlink" title="modeling"></a>modeling</h4><p>promises 对 store hoisting 建模：</p>
<ul>
<li><strong>Goal:</strong> allowing the hoisting of <strong>semantically independent writes</strong> only</li>
<li><strong>Idea:</strong> “semantically independent writes” are <strong>always writable</strong> in the future</li>
<li><strong>Mechanism</strong><ul>
<li>A thread may speculatively write a value (“promise to write”)</li>
<li>A thread should <strong>always be able to write its promises</strong> in the future</li>
</ul>
</li>
</ul>
<p>（1）例一：store hoisting w&#x2F;o dependency（r1&#x3D;r2&#x3D;1 allowed by reordering in the thread 2）</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-2.png" srcset="/img/loading.gif" lazyload class="">

<p>为了验证线程2可以完成 promise write，需要屏蔽掉线程1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-5.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 0</code> message，线程2视图保持不变。接着，线程2执行 <code>X = 1</code>，插入 X &#x3D; 1 message，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-6.png" srcset="/img/loading.gif" lazyload class="">

<p>promise write 得到验证，将线程2的视图还原，并将 X &#x3D; 1 message 标记为 Certified：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-7.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>r1 = X</code>，假设读取 X &#x3D; 1 message，则线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-8.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-9.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2 = Y</code>，假设读取 Y &#x3D; 1 message，则线程2的视图更新为 X &#x3D; 0 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-10.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2可以执行 <code>X = 1</code> 兑现 promise write，因此 promise 得到二次验证，将 X &#x3D; 1 message 标记为 Re-Certified：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-11.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>X = 1</code>，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-1-12.png" srcset="/img/loading.gif" lazyload class="">



<p>（2）例二：store hoisting w&#x2F; dependency（r1&#x3D;r2&#x3D;1 disallowed, OOTA）</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-2-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message。屏蔽线程1，线程2执行 <code>r2 = Y</code> 读取 Y &#x3D; 0 message，因此 r2 &#x3D; 0。线程2执行 <code>X = r2</code>，因为 r2 &#x3D; 0，线程2无法兑现 promise write，执行失败。</p>
<p>因此 r1 &#x3D; r2 &#x3D; 1 不可能成立。</p>
<p>（3）例三：store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;1 allowed）</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2 promise to write X &#x3D; 1，插入 X &#x3D; 1 message：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-2.png" srcset="/img/loading.gif" lazyload class="">

<p>为了验证线程2可以兑现 promise write，需要屏蔽掉线程1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-5.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 0</code> message，线程2视图保持不变。接着，线程2进入 else 分支，执行 <code>X = 1</code>，插入 X &#x3D; 1 message，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-6.png" srcset="/img/loading.gif" lazyload class="">

<p>promise write 得到验证，将线程2的视图还原，并将 X &#x3D; 1 message 标记为 Certified：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-7.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>r1 = X</code>，假设读取 X &#x3D; 1 message，则线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-8.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-9.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2 = Y</code>，假设读取 Y &#x3D; 1 message，则线程2的视图更新为 X &#x3D; 0 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-10.png" srcset="/img/loading.gif" lazyload class="">

<p>因为 <code>r2 = 1</code>，线程2执行 <code>if r2 == 1</code> 进入 if 分支内部，接着可执行 <code>X = r2</code> 兑现 promise write，因此 promise 得到二次验证，将 X &#x3D; 1 message 标记为 Re-Certified：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-11.png" srcset="/img/loading.gif" lazyload class="">

<p>最后，线程2执行 <code>X = r2</code>，兑现 promise write，线程2的视图更新为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-3-12.png" srcset="/img/loading.gif" lazyload class="">



<p>（4）例四：store hoisting w&#x2F; syntactic dependency（r1&#x3D;r2&#x3D;r3&#x3D;1 disallowed due to RW coherence）</p>
<p>线程2 promise to write X &#x3D; 1，并验证 promise（验证过程与前面的例子一致，这里跳过）：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-4-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>r1 = X</code>，假设读到 X &#x3D; 1 message，则线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 0：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-4-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1执行 <code>Y = r1</code>，插入 Y &#x3D; 1 message，线程1的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-4-3.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2执行 <code>r2=Y</code>，读取 <code>Y = 1</code> message，线程2的视图变为 X &#x3D; 0 &amp; Y &#x3D; 1。接着，线程2执行 <code>r3 = X</code>，假设读到 X &#x3D; 1 message，则线程2的视图变为 X &#x3D; 1 &amp; Y &#x3D; 1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-4-4.png" srcset="/img/loading.gif" lazyload class="">

<p>由于 <code>r2 = 1</code>，因此进入 if 分支内部执行 <code>X = r2</code>，由于线程2的视图已经变为 X &#x3D; 1 &amp; Y &#x3D; 1，因此只能在当前视图的右边插入新的 X &#x3D; 1 message，那么就无法兑现 promise write，执行失败：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/promises-4-5.png" srcset="/img/loading.gif" lazyload class="">

<p>因此 r1 &#x3D; r2 &#x3D; r3 &#x3D; 1 不可能成立。</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>Promising semantics is an operational semantics modeling relaxed behaviors and orderings.</p>
<p><strong>Key ideas</strong></p>
<ul>
<li><strong>Multi-valued memory:</strong> modeling load hoisting</li>
<li><strong>Message adjacency:</strong> modeling read-modify-write</li>
<li><strong>Views:</strong> modeling coherence and synchronization</li>
<li><strong>Promises:</strong> modeling store hoisting</li>
</ul>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><h3 id="Spin-lock"><a href="#Spin-lock" class="headerlink" title="Spin lock"></a>Spin lock</h3><p>Spin lock 代码：<a target="_blank" rel="noopener" href="https://github.com/kaist-cp/cs431/blob/main/src/lock/spinlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/spinlock.rs</a>。 关键方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">cas</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, acquire).<span class="hljs-title function_ invoke__">is_err</span>() &#123;&#125; <br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <br>    <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, release);            <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Lock Guarantee：</p>
<ul>
<li>If a lock has already been acquired, lock() will spin.</li>
<li>Events between lock &amp; unlock are transferred via release&#x2F;acquire synch.</li>
<li>When holding the lock, you’ll access the latest value of D (no shared access).</li>
</ul>
<p>L 表示锁的状态，F 表示锁没有被占用，T 表示锁被占用了。D 表示锁保护的数据。绿色线条表示线程1 view，黑色线条表示线程2 view，黄色线条表示 message view。初始状态下，线程1的 view 和线程2的 view 相同：L &#x3D; F &amp; D &#x3D; Something1，message view 为上一个线程是否锁后产生的：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-1.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1调用 <code>lock</code> 函数获取锁，执行 <code>cas(false, true, acquire)</code> 操作，读取 L &#x3D; F message，因此 cas 操作执行成功，邻接 L &#x3D; T message，由于使用了 acquire，message view 会合并到线程1的 view 中，线程1的 view 变为 L &#x3D; T &amp; D &#x3D; Something1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-2.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1持有锁，并修改 D，插入 D &#x3D; Something2 message，线程1的view 变为 L &#x3D; T &amp; D &#x3D; Something2：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-3.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2调用 <code>lock</code> 函数获取锁，由于 L &#x3D; F message 已经被邻接了，只能读到 L &#x3D; T message，因此 cas 操作失败，进入 while 循环自旋，由于使用了 acquire，message view 会合并到线程2的 view 中，线程2的 view 变为 L &#x3D; T &amp; D &#x3D; Something1：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-4.png" srcset="/img/loading.gif" lazyload class="">

<p>线程1调用 <code>unlock</code> 函数释放锁，执行 <code>store(false, release)</code> 操作，插入 L &#x3D; F message，线程1的视图变为 L &#x3D; F &amp; D &#x3D; Something2，由于使用了 release，会生成 message view：L &#x3D; F &amp; D &#x3D; Something2：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-5.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2调用 <code>lock</code> 函数获取锁，执行 <code>cas(false, true, acquire)</code> 操作，假设读到第二个 L &#x3D; F message，因此 cas 操作执行成功，邻接 L &#x3D; T message，由于使用了 acquire，message view 会合并到线程2的 view 中，线程2的 view 变为 L &#x3D; T &amp; D &#x3D; Something2：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-6.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2持有锁，并修改 D，插入 D &#x3D; Something3 message，线程2的view 变为 L &#x3D; T &amp; D &#x3D; Something3：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-7.png" srcset="/img/loading.gif" lazyload class="">

<p>线程2调用 <code>unlock</code> 函数释放锁，执行 <code>store(false, release)</code> 操作，插入 L &#x3D; F message，线程2的视图变为 L &#x3D; F &amp; D &#x3D; Something3，由于使用了 release，会生成 message view：L &#x3D; F &amp; D &#x3D; Something3：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-8.png" srcset="/img/loading.gif" lazyload class="">

<p>最后，全图执行流程如下所示：</p>
<img src="/2022/11/27/relaxed-memory-concurrency/spin-lock-9.png" srcset="/img/loading.gif" lazyload class="">

<p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，因此多个线程不会同时读写锁保护的数据，并且当一个线程持有锁时，另一个线程尝试获取锁则会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p>
<h3 id="Ticket-lock"><a href="#Ticket-lock" class="headerlink" title="Ticket lock"></a>Ticket lock</h3><p>Ticket lock 代码：<a target="_blank" rel="noopener" href="https://github.com/kaist-cp/cs431/blob/main/src/lock/ticketlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/ticketlock.rs</a>。关键方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ticket</span> = <span class="hljs-keyword">self</span>.next.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.curr.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) != ticket &#123;&#125;<br><br>    ticket<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>, ticket: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">self</span>.curr.<span class="hljs-title function_ invoke__">store</span>(ticket.<span class="hljs-title function_ invoke__">wrapping_add</span>(<span class="hljs-number">1</span>), Ordering::Release);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2022/11/27/relaxed-memory-concurrency/ticket-lock.png" srcset="/img/loading.gif" lazyload class="">

<p>D 表示被锁保护的数据，绿色线条表示线程1，蓝色线条表示线程2。初始状态下，线程1的 view 为 next &#x3D; 0 &amp; cur &#x3D; 0 &amp; D &#x3D; D0，线程的 view 为 next &#x3D; 0 &amp; cur &#x3D; 0 &amp; D &#x3D; D0。执行流程描述如下：</p>
<ul>
<li>线程1执行 <code>self.next.fetch_add(1)</code>，读取 next &#x3D; 0 message，邻接 next &#x3D; 1 message，获取 ticket &#x3D; 0。接着执行 <code>self.curr.load</code>，读取 cur &#x3D; 0 message，因为 cur &#x3D; ticket &#x3D; 0，因此结束循环，返回 ticket，线程1的视图最终变为 next &#x3D; 1 &amp; cur &#x3D; 0 &amp; D &#x3D; D0；</li>
<li>线程2执行 <code>self.next.fetch_add(1)</code>，读取 next &#x3D; 1 message，邻接 next &#x3D; 2 message，获取 ticket &#x3D; 1。接着执行 <code>self.curr.load</code>，读取 cur &#x3D; 0 message，因为 cur !&#x3D; ticket，因此开始自旋，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 0 &amp; D &#x3D; D0；</li>
<li>线程1修改 D，插入 D &#x3D; D1 message，线程1的视图更新为 next &#x3D; 1 &amp; cur &#x3D; 0 &amp; D &#x3D; D1；</li>
<li>线程1释放锁，执行 <code>self.curr.store(ticket.wrapping_add(1), Release)</code> ，插入 cur &#x3D; 1 message，线程1的视图更新为 next &#x3D; 1 &amp; cur &#x3D; 1 &amp; D &#x3D; D1。因为使用了 Release，生成 message view：next &#x3D; 1 &amp; cur &#x3D; 1 &amp; D &#x3D; D1；</li>
<li>线程2执行 <code>self.curr.load(Ordering::Acquire)</code> ，假设读到 cur &#x3D; 1 message，此时 cur &#x3D; ticket &#x3D; 1，因此结束循环，返回 ticket，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D0。因为使用了 Acquire，把 message view 合并到线程2的view中，线程2的视图变为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D1；</li>
<li>线程2修改 D，插入 D &#x3D; D2 message，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 1 &amp; D &#x3D; D2；</li>
<li>线程2释放锁，执行 <code>self.curr.store(ticket.wrapping_add(1), Release)</code> ，插入 cur &#x3D; 2 message，线程2的视图更新为 next &#x3D; 2 &amp; cur &#x3D; 2 &amp; D &#x3D; D2。因为使用了 Release，生成 message view：next &#x3D; 2 &amp; cur &#x3D; 2 &amp; D &#x3D; D2。</li>
</ul>
<p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，当一个线程持有锁时，另一个线程尝试获取锁会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p>
<h3 id="Clh-lock"><a href="#Clh-lock" class="headerlink" title="Clh lock"></a>Clh lock</h3><p>Clh lock 代码：<a target="_blank" rel="noopener" href="https://github.com/kaist-cp/cs431/blob/main/src/lock/clhlock.rs">https://github.com/kaist-cp/cs431/blob/main/src/lock/clhlock.rs</a>。关键方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Token &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = Box::<span class="hljs-title function_ invoke__">into_raw</span>(Box::<span class="hljs-title function_ invoke__">new</span>(CachePadded::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">true</span>))));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">prev</span> = <span class="hljs-keyword">self</span>.tail.<span class="hljs-title function_ invoke__">swap</span>(node, Ordering::AcqRel);<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">unsafe</span> &#123; (*prev).locked.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#125; &#123;&#125;<br><br>    <span class="hljs-title function_ invoke__">drop</span>(<span class="hljs-keyword">unsafe</span> &#123; Box::<span class="hljs-title function_ invoke__">from_raw</span>(prev) &#125;);<br>    <span class="hljs-title function_ invoke__">Token</span>(node)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>, token: <span class="hljs-keyword">Self</span>::Token) &#123;<br>    (*token.<span class="hljs-number">0</span>).locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Ordering::Release);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2022/11/27/relaxed-memory-concurrency/clh-lock.png" srcset="/img/loading.gif" lazyload class="">

<p>D 表示被锁保护的数据，绿色线条表示线程1，蓝色线条表示线程2。初始状态下，线程1的 view 为 tail &#x3D; t0 &amp; node0 &#x3D; F &amp; D &#x3D; D0，线程2的 view 为 tail &#x3D; t0 &amp; node0 &#x3D; F &amp; D &#x3D; D0。执行流程描述如下：</p>
<ul>
<li>线程1调用lock函数，创建 node1，插入 node1 &#x3D; T message。线程1执行 <code>self.tail.swap(node1, AcqRel)</code>，读取 tail &#x3D; t0 message，邻接 tail &#x3D; t1 message，线程1的视图更新为 tail &#x3D; t1 &amp; node0 &#x3D; F &amp; node1 &#x3D; T &amp; D &#x3D; D0。由于使用了 AcqReq，生成 tail &#x3D; t1 的message view：tail &#x3D; t1 &amp; node0 &#x3D; F &amp; node1 &#x3D; T &amp; D &#x3D; D0。线程1执行 <code>(*node0).locked.load(Ordering::Acquire)</code>，读取 node0 &#x3D; F message，退出 while 循环。线程1执行 <code>drop(unsafe &#123; Box::from_raw(node0) &#125;)</code>，此时 node0 不会再有线程方法它，因此可以把 node0 相关的 message 从线程视图中删除，线程1 view 更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D0， tail &#x3D; t1 的message view    更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D0。线程1 返回 Token(node1)，此时线程1成功获取锁；</li>
<li>线程2调用lock函数，创建node2，插入 node2 &#x3D; T message。线程2执行 <code>self.tail.swap(node2, AcqRel)</code>，读取 tail &#x3D; t1 message，邻接 tail &#x3D; t2 message，由于使用使用了 AcqRel，因此将 tail &#x3D; t1 message view合并到线程2的视图中，线程2的视图更新为 tail &#x3D; t2 &amp; node1 &#x3D; T &amp; node2 &#x3D; T &amp; D &#x3D; D0，同时生成 tail &#x3D; t2 message view：tail &#x3D; t2 &amp; node1 &#x3D; T &amp; node2 &#x3D; T &amp; D &#x3D; D0。线程2执行 <code>(*node1).locked.load(Ordering::Acquire)</code>，读取 node1 &#x3D; T message，进入自旋；</li>
<li>线程1修改 D，插入 D &#x3D; D1 message，线程1的视图更新为 tail &#x3D; t1 &amp; node1 &#x3D; T &amp; D &#x3D; D1；</li>
<li>线程1释放锁，执行 <code>(*node1).locked.store(false, Release);</code> ，插入 node1 &#x3D; F message，线程1的视图更新为 tail &#x3D; t1 &amp; node1 &#x3D; F &amp; D &#x3D; D1。因为使用了 Release，生成 node1 &#x3D; F message view：tail &#x3D; t1 &amp; node1 &#x3D; F &amp; D &#x3D; D1；</li>
<li>线程2执行 <code>(*node1).locked.load(Ordering::Acquire)</code>，假设读到 node1 &#x3D; F message，则退出循环，由于使用了 Acquire，将 node1 &#x3D; F message view 合并线程2的 view中，线程2的视图更新为 tail &#x3D; t2 &amp; node1 &#x3D; F &amp; node2 &#x3D; T &amp; D &#x3D; D1。线程2执行 <code>drop(unsafe &#123; Box::from_raw(node1) &#125;)</code>，此时 node1 不会再有线程方法它，因此可以把 node1 相关的 message 从线程视图中删除，线程2 view 更新为 tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D1， tail &#x3D; t2 的message view    更新为 tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D1。线程2 返回 Token(node2)，此时线程2成功获取锁；</li>
<li>线程2修改 D，插入 D &#x3D; D2 message，线程2的视图更新为  tail &#x3D; t2 &amp; node2 &#x3D; T &amp; D &#x3D; D2；</li>
<li>线程2释放锁，执行 <code>(*node2).locked.store(false, Release);</code> ，插入 node2 &#x3D; F message，线程2的视图更新为 tail &#x3D; t2 &amp; node2 &#x3D; F &amp; D &#x3D; D2。因为使用了 Release，生成 node2 &#x3D; F message view：tail &#x3D; t2 &amp; node2 &#x3D; F &amp; D &#x3D; D2。</li>
</ul>
<p>综上所述，线程1和线程2持有锁的 timestamp 区间不相交，当一个线程持有锁时，另一个线程尝试获取锁会进入自旋。此外，通过 Release&#x2F;Acquire 实现了 message passing，保证当一个线程持有锁时，访问到的是最新的数据。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/concurrent/" class="category-chain-item">concurrent</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/consistency/">#consistency</a>
      
        <a href="/tags/rust/">#rust</a>
      
        <a href="/tags/note/">#note</a>
      
        <a href="/tags/lock-free/">#lock-free</a>
      
        <a href="/tags/concurrent/">#concurrent</a>
      
        <a href="/tags/relaxed-memory/">#relaxed memory</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Relaxed Memory Concurrency</div>
      <div>https://night-cruise.github.io/2022/11/27/relaxed-memory-concurrency/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Night Cruise</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/08/hazard-pointers/" title="Hazard Pointers">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hazard Pointers</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/19/cacher-blog/" title="Cacher and Blog">
                        <span class="hidden-mobile">Cacher and Blog</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
